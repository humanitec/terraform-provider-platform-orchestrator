// Package canyondp provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/oapi-codegen/oapi-codegen/v2 version v2.4.1 DO NOT EDIT.
package canyondp

import (
	"bytes"
	"context"
	"encoding/json"
	"errors"
	"fmt"
	"io"
	"net/http"
	"net/url"
	"strings"
	"time"

	"github.com/oapi-codegen/runtime"
	openapi_types "github.com/oapi-codegen/runtime/types"
)

const (
	JwtAuthScopes      = "jwtAuth.Scopes"
	UserIdHeaderScopes = "userIdHeader.Scopes"
)

// Defines values for DeploymentCreateBodyMode.
const (
	Deploy   DeploymentCreateBodyMode = "deploy"
	PlanOnly DeploymentCreateBodyMode = "plan_only"
)

// Defines values for DeploymentResultsUpdateBodyStatus.
const (
	Failure DeploymentResultsUpdateBodyStatus = "failure"
	Success DeploymentResultsUpdateBodyStatus = "success"
)

// Defines values for MetadataKeySchemaType.
const (
	MetadataKeySchemaTypeString MetadataKeySchemaType = "string"
)

// Defines values for RemoteRunnerMessageAction.
const (
	CreateJob    RemoteRunnerMessageAction = "create-job"
	GetJobStatus RemoteRunnerMessageAction = "get-job-status"
)

// Defines values for UpdateMetadataKeySchemaType.
const (
	UpdateMetadataKeySchemaTypeString UpdateMetadataKeySchemaType = "string"
)

// ActiveResourceNode A node in the active resource graph
type ActiveResourceNode struct {
	DeploymentId openapi_types.UUID `json:"deployment_id"`
	Edges        map[string]string  `json:"edges"`

	// EnvId The environment id.
	EnvId string `json:"env_id"`

	// Id The deterministic hash of the node in the graph. This hash is also used in the edges map for each node.
	Id            string                 `json:"id"`
	Metadata      map[string]interface{} `json:"metadata"`
	ModuleId      string                 `json:"module_id"`
	ModuleVersion string                 `json:"module_version"`

	// ProjectId The Project id of the environment of this node.
	ProjectId     string `json:"project_id"`
	ResourceClass string `json:"resource_class"`
	ResourceId    string `json:"resource_id"`
	ResourceType  string `json:"resource_type"`
}

// Deployment defines model for Deployment.
type Deployment struct {
	// CompletedAt The time the deployment succeeded, failed, or terminated
	CompletedAt *time.Time `json:"completed_at,omitempty"`

	// CreatedAt The time the deployment was created
	CreatedAt time.Time `json:"created_at"`

	// EnvId The Environment id in the project which is being deployed
	EnvId string `json:"env_id"`

	// Id The unique deployment id
	Id DeploymentId `json:"id"`

	// Manifest The manifest associated with a deployment
	Manifest DeploymentManifest `json:"manifest"`

	// Metrics Metrics resulting from a deployment.
	Metrics DeploymentMetrics `json:"metrics"`

	// Mode The mode of the deployment.
	Mode string `json:"mode"`

	// OrgId The Organization ID
	OrgId OrganizationId `json:"org_id"`

	// ProjectId The Project id which the environment exists in
	ProjectId string `json:"project_id"`

	// RunnerId The Runner ID that this deployment executes on
	RunnerId string `json:"runner_id"`

	// Status The status of the deployment.
	Status string `json:"status"`

	// StatusMessage A message associated with the 'status'.
	StatusMessage string `json:"status_message"`
}

// DeploymentCreateBody defines model for DeploymentCreateBody.
type DeploymentCreateBody struct {
	// EncryptedOutputsRecipient A recipient public key must be provided in order to access encrypted outputs of the deployment. This must be an 'age' public key (see https://age-encryption.org).
	// The caller must hold the matching private key in order to decrypt the outputs when the deployment completes. If the recipient key is not set, no outputs will be captured
	// from the deployment.
	EncryptedOutputsRecipient *string `json:"encrypted_outputs_recipient,omitempty"`

	// EnvId The environment to deploy to.
	EnvId string `json:"env_id"`

	// IsDryRun Whether to just validate the request and not persist or execute it.
	IsDryRun bool `json:"is_dry_run,omitempty"`

	// Manifest The manifest associated with a deployment
	Manifest DeploymentManifest `json:"manifest"`

	// Mode The mode of the deployment. Defaults to 'deploy'. Can be set to 'plan_only' to test and validate a deployment.
	Mode DeploymentCreateBodyMode `json:"mode"`

	// ProjectId The Project to deploy to.
	ProjectId string `json:"project_id"`
}

// DeploymentCreateBodyMode The mode of the deployment. Defaults to 'deploy'. Can be set to 'plan_only' to test and validate a deployment.
type DeploymentCreateBodyMode string

// DeploymentDryRun defines model for DeploymentDryRun.
type DeploymentDryRun struct {
	// RunnerId The Runner ID that this deployment would have executed on
	RunnerId string `json:"runner_id"`
}

// DeploymentEncryptedOutputs defines model for DeploymentEncryptedOutputs.
type DeploymentEncryptedOutputs struct {
	// Raw The base64 encoded encrypted outputs. These are returned in standard base64 with padding. The outputs are encrypted with https://age-encryption.org/ and may
	// be decrypted by the holder of the recipients key.
	Raw string `json:"raw"`
}

// DeploymentId The unique deployment id
type DeploymentId = openapi_types.UUID

// DeploymentManifest The manifest associated with a deployment
type DeploymentManifest struct {
	// Shared The set of named shared resources.
	Shared map[string]DeploymentManifestResource `json:"shared,omitempty"`

	// Workloads The set of workloads in the environment.
	Workloads map[string]DeploymentManifestWorkload `json:"workloads"`
}

// DeploymentManifestResource A resource to provision as part of the deployment
type DeploymentManifestResource struct {
	// Class A resource class requested by the resource graph. 'default' is the default value.
	Class *ResourceClass `json:"class,omitempty"`

	// Id A specific resource id requested by the resource graph
	Id *ResourceId `json:"id,omitempty"`

	// Params Optional parameters to pass to the resource provisioning.
	Params map[string]interface{} `json:"params,omitempty"`

	// Type The resource type to provision
	Type string `json:"type"`
}

// DeploymentManifestWorkload defines model for DeploymentManifestWorkload.
type DeploymentManifestWorkload struct {
	Resources map[string]DeploymentManifestResource `json:"resources,omitempty"`
	Variables map[string]string                     `json:"variables,omitempty"`
}

// DeploymentMetrics Metrics resulting from a deployment.
type DeploymentMetrics struct {
	// NumResourceNodes The number of resource nodes in the graph.
	NumResourceNodes int `json:"num_resource_nodes"`

	// NumTfResources The number of terraformed resources. Only known after deployment.
	NumTfResources *int `json:"num_tf_resources,omitempty"`

	// NumTfResourcesAdded The number of terraformed resources added. Only known after deployment.
	NumTfResourcesAdded *int `json:"num_tf_resources_added,omitempty"`

	// NumTfResourcesChanged The number of terraformed resources changed. Only known after deployment.
	NumTfResourcesChanged *int `json:"num_tf_resources_changed,omitempty"`

	// NumTfResourcesRemoved The number of terraformed resources removed. Only known after deployment.
	NumTfResourcesRemoved *int `json:"num_tf_resources_removed,omitempty"`

	// NumWorkloads The number of workloads in the deployment.
	NumWorkloads int `json:"num_workloads"`
}

// DeploymentPage A page of deployments
type DeploymentPage struct {
	Items []DeploymentSummary `json:"items"`

	// NextPageToken The page token to use to request the next page of items
	NextPageToken *string `json:"next_page_token,omitempty"`
}

// DeploymentResultMetadata The metadata produced by the resources involved in the deployment.
type DeploymentResultMetadata = []DeploymentResultMetadataPerNode

// DeploymentResultMetadataPerNode The metadata produced by a specific resource identified by its hash.
type DeploymentResultMetadataPerNode struct {
	// Metadata The metadata output by the module which provisioned the resource.
	Metadata map[string]interface{} `json:"metadata"`

	// NodeId The hash of the active resource node.
	NodeId string `json:"node_id"`
}

// DeploymentResultsUpdateBody The outcome of the runner execution.
type DeploymentResultsUpdateBody struct {
	// Error A standard error response
	Error *Error `json:"error,omitempty"`

	// Metadata The metadata produced by the resources involved in the deployment.
	Metadata DeploymentResultMetadata `json:"metadata,omitempty"`

	// Outputs The encrypted outputs produced by the runner.
	Outputs *string `json:"outputs,omitempty"`

	// Status The overall status of the runner execution.
	Status DeploymentResultsUpdateBodyStatus `json:"status"`

	// TfResourceCounts Details about the Terraform resources added / removed / changed .
	TfResourceCounts DeploymentTFResourceCounts `json:"tf_resource_counts,omitempty"`
}

// DeploymentResultsUpdateBodyStatus The overall status of the runner execution.
type DeploymentResultsUpdateBodyStatus string

// DeploymentSummary Summary information for a deployment, more information can be retrieved through the GetDeployment APIs.
type DeploymentSummary struct {
	// CompletedAt The time the deployment succeeded, failed, or terminated
	CompletedAt *time.Time `json:"completed_at,omitempty"`

	// CreatedAt The time the deployment was created
	CreatedAt time.Time `json:"created_at"`

	// EnvId The Environment id in the project which is being deployed
	EnvId string `json:"env_id"`

	// Id The unique deployment id
	Id DeploymentId `json:"id"`

	// Metrics Metrics resulting from a deployment.
	Metrics DeploymentMetrics `json:"metrics"`

	// Mode The mode of the deployment.
	Mode string `json:"mode"`

	// OrgId The Organization ID
	OrgId OrganizationId `json:"org_id"`

	// ProjectId The Project id which the environment exists in
	ProjectId string `json:"project_id"`

	// Status The status of the deployment.
	Status string `json:"status"`

	// StatusMessage A message associated with the 'status'.
	StatusMessage string `json:"status_message"`
}

// DeploymentTFResourceCounts Details about the Terraform resources added / removed / changed .
type DeploymentTFResourceCounts struct {
	// NumResources Number of Terraform resources involved in the deployment.
	NumResources int `json:"num_resources"`

	// NumResourcesAdded Number of Terraform resources added by this deployment run.
	NumResourcesAdded int `json:"num_resources_added"`

	// NumResourcesChanged Number of Terraform resources changed by this deployment run.
	NumResourcesChanged int `json:"num_resources_changed"`

	// NumResourcesRemoved Number of Terraform resources removed by this deployment run.
	NumResourcesRemoved int `json:"num_resources_removed"`
}

// Error A standard error response
type Error struct {
	// Details An optional payload of metadata associated with the error.
	Details *map[string]interface{} `json:"details,omitempty"`

	// Error A short code representing the class of error. This code can be used for tracking and observability or to
	// find appropriate troubleshooting documentation.
	Error string `json:"error"`

	// Message A human-readable explanation of the error.
	Message string `json:"message"`
}

// InternalModuleUsage defines model for InternalModuleUsage.
type InternalModuleUsage struct {
	EnvIdsByProjectId map[string][]string `json:"env_ids_by_project_id"`
}

// Jwk JSON Web Key
type Jwk struct {
	Alg string    `json:"alg"`
	E   string    `json:"e"`
	Kid string    `json:"kid"`
	Kty string    `json:"kty"`
	N   string    `json:"n"`
	Use string    `json:"use"`
	X5c *[]string `json:"x5c,omitempty"`
	X5t *string   `json:"x5t,omitempty"`
}

// Jwks JSON Web Keys Set (JWKS).
type Jwks struct {
	Keys []Jwk `json:"keys"`
}

// ListActiveResourceNodesPage defines model for ListActiveResourceNodesPage.
type ListActiveResourceNodesPage struct {
	// Items The list of active resource nodes.
	Items []ActiveResourceNode `json:"items"`
}

// MetadataKey A metadata key for an organization.
type MetadataKey struct {
	// CreatedAt The time the metadata key was created
	CreatedAt time.Time `json:"created_at"`

	// Description A human-readable description of the metadata key.
	Description *string `json:"description,omitempty"`

	// Name The name of the metadata key.
	Name string `json:"name"`

	// Schema The schema of the metadata key.
	Schema MetadataKeySchema `json:"schema"`
}

// MetadataKeyCreateBody A metadata key for an organization.
type MetadataKeyCreateBody struct {
	// Description A human-readable description of the metadata key.
	Description *string `json:"description,omitempty"`

	// Name The name of the metadata key.
	Name string `json:"name"`

	// Schema The schema of the metadata key.
	Schema MetadataKeySchema `json:"schema"`
}

// MetadataKeyPage A page of metadata keys
type MetadataKeyPage struct {
	Items []MetadataKey `json:"items"`

	// NextPageToken The page token to use to request the next page of items
	NextPageToken *string `json:"next_page_token,omitempty"`
}

// MetadataKeySchema The schema of the metadata key.
type MetadataKeySchema struct {
	// Format The format of the metadata key.
	Format *string `json:"format,omitempty"`

	// Pattern A regular expression pattern for the metadata key.
	Pattern *string `json:"pattern,omitempty"`

	// Type The type of the metadata key.
	Type MetadataKeySchemaType `json:"type"`
}

// MetadataKeySchemaType The type of the metadata key.
type MetadataKeySchemaType string

// MetadataKeyUpdateBody A metadata key for an organization.
type MetadataKeyUpdateBody struct {
	// Description A human-readable description of the metadata key.
	Description *string `json:"description,omitempty"`

	// Schema The schema of the metadata key.
	Schema *UpdateMetadataKeySchema `json:"schema,omitempty"`
}

// OpenidConfiguration OpenID discovery configuration.
type OpenidConfiguration struct {
	ClaimsSupported                  []string `json:"claims_supported"`
	IdTokenSigningAlgValuesSupported []string `json:"id_token_signing_alg_values_supported"`
	Issuer                           string   `json:"issuer"`
	JwksUri                          string   `json:"jwks_uri"`
	ResponseTypesSupported           []string `json:"response_types_supported"`
	ScopesSupported                  []string `json:"scopes_supported"`
	SubjectTypesSupported            []string `json:"subject_types_supported"`
}

// OrganizationId The Organization ID
type OrganizationId = string

// RemoteRunnerMessage defines model for RemoteRunnerMessage.
type RemoteRunnerMessage struct {
	union json.RawMessage
}

// RemoteRunnerMessageAction The action to be performed by the remote runner.
type RemoteRunnerMessageAction string

// RemoteRunnerMessageCreateJob The response for creating a job on the runner.
type RemoteRunnerMessageCreateJob struct {
	// Action The action to be performed by the remote runner.
	Action RemoteRunnerMessageAction `json:"action"`

	// Configuration The configuration for the job to be created on the runner. It must be parsable into a kubernetes Job definition.
	Configuration map[string]interface{} `json:"configuration"`

	// DeploymentToken The deployment token to authenticate any request to update deployment results from the remote runner.
	DeploymentToken string `json:"deployment_token"`

	// JobId The ID of the job created on the runner.
	JobId string `json:"job_id"`

	// Namespace The ID of the namespace associated with the job.
	Namespace string `json:"namespace"`
}

// RemoteRunnerMessageGetJobStatus The response for getting the status of a job on the runner.
type RemoteRunnerMessageGetJobStatus struct {
	// Action The action to be performed by the remote runner.
	Action RemoteRunnerMessageAction `json:"action"`

	// DeploymentToken The deployment token to authenticate any request to update deployment results from the remote runner.
	DeploymentToken string `json:"deployment_token"`

	// JobId The ID of the job whose status is being requested.
	JobId string `json:"job_id"`

	// Namespace The ID of the namespace associated with the job.
	Namespace string `json:"namespace"`
}

// ResourceClass A resource class requested by the resource graph. 'default' is the default value.
type ResourceClass = string

// ResourceId A specific resource id requested by the resource graph
type ResourceId = string

// UpdateMetadataKeySchema The schema of the metadata key.
type UpdateMetadataKeySchema struct {
	// Format The format of the metadata key.
	Format *string `json:"format,omitempty"`

	// Pattern A regular expression pattern for the metadata key.
	Pattern *string `json:"pattern,omitempty"`

	// Type The type of the metadata key.
	Type *UpdateMetadataKeySchemaType `json:"type,omitempty"`
}

// UpdateMetadataKeySchemaType The type of the metadata key.
type UpdateMetadataKeySchemaType string

// DeploymentIdPathParam defines model for deploymentIdPathParam.
type DeploymentIdPathParam = openapi_types.UUID

// EnvIdQueryParam defines model for envIdQueryParam.
type EnvIdQueryParam = string

// MetadataKeyNamePathParam defines model for metadataKeyNamePathParam.
type MetadataKeyNamePathParam = string

// OrgIdPathParam defines model for orgIdPathParam.
type OrgIdPathParam = string

// PageTokenQueryParam defines model for pageTokenQueryParam.
type PageTokenQueryParam = string

// PerPageQueryParam defines model for perPageQueryParam.
type PerPageQueryParam = int

// ProjectIdQueryParam defines model for projectIdQueryParam.
type ProjectIdQueryParam = string

// RunnerIdPathParam defines model for runnerIdPathParam.
type RunnerIdPathParam = string

// N400BadRequest A standard error response
type N400BadRequest = Error

// N404NotFound A standard error response
type N404NotFound = Error

// N409Conflict A standard error response
type N409Conflict = Error

// InternalDeleteDeploymentsParams defines parameters for InternalDeleteDeployments.
type InternalDeleteDeploymentsParams struct {
	// ProjectId The Project ID
	ProjectId *ProjectIdQueryParam `form:"project_id,omitempty" json:"project_id,omitempty"`

	// EnvId The Environment ID
	EnvId *EnvIdQueryParam `form:"env_id,omitempty" json:"env_id,omitempty"`

	// Force Whether to ignore the requirement for the last deployment to be a successful destroy. This should only be used in exceptional circumstances.
	Force *bool `form:"force,omitempty" json:"force,omitempty"`
}

// InternalCheckModuleUsageParams defines parameters for InternalCheckModuleUsage.
type InternalCheckModuleUsageParams struct {
	ModuleVersion *string `form:"module_version,omitempty" json:"module_version,omitempty"`
}

// ListActiveResourceNodesParams defines parameters for ListActiveResourceNodes.
type ListActiveResourceNodesParams struct {
	// ProjectId The Project ID
	ProjectId *ProjectIdQueryParam `form:"project_id,omitempty" json:"project_id,omitempty"`

	// EnvId The Environment ID
	EnvId *EnvIdQueryParam `form:"env_id,omitempty" json:"env_id,omitempty"`
}

// ListDeploymentsParams defines parameters for ListDeployments.
type ListDeploymentsParams struct {
	// ProjectId The Project ID
	ProjectId *ProjectIdQueryParam `form:"project_id,omitempty" json:"project_id,omitempty"`

	// EnvId The Environment ID
	EnvId *EnvIdQueryParam `form:"env_id,omitempty" json:"env_id,omitempty"`

	// PerPage The maximum number of items to return in a page of results
	PerPage *PerPageQueryParam `form:"per_page,omitempty" json:"per_page,omitempty"`

	// Page The page token to request from
	Page *PageTokenQueryParam `form:"page,omitempty" json:"page,omitempty"`
}

// CreateDeploymentParams defines parameters for CreateDeployment.
type CreateDeploymentParams struct {
	// IdempotencyKey Ensures that the deployment request is only accepted once per idempotency key per 24 hours. A uuid or similar is recommended.
	// When the key matches the key in last deployment and the environment and manifest is the same, this will return the last deployment.
	IdempotencyKey *string `json:"Idempotency-Key,omitempty"`
}

// WaitForDeploymentCompleteParams defines parameters for WaitForDeploymentComplete.
type WaitForDeploymentCompleteParams struct {
	// TimeoutInSeconds Sets a maximum timeout before the HTTP-408 response is returned.
	TimeoutInSeconds *int `form:"timeout_in_seconds,omitempty" json:"timeout_in_seconds,omitempty"`
}

// GetDeploymentBundleParams defines parameters for GetDeploymentBundle.
type GetDeploymentBundleParams struct {
	XDeploymentToken string `json:"X-Deployment-Token"`
}

// UpdateDeploymentResultsParams defines parameters for UpdateDeploymentResults.
type UpdateDeploymentResultsParams struct {
	XDeploymentToken string `json:"X-Deployment-Token"`
}

// ListLastDeploymentsParams defines parameters for ListLastDeployments.
type ListLastDeploymentsParams struct {
	// ProjectId The Project ID
	ProjectId *ProjectIdQueryParam `form:"project_id,omitempty" json:"project_id,omitempty"`

	// EnvId The Environment ID
	EnvId *EnvIdQueryParam `form:"env_id,omitempty" json:"env_id,omitempty"`

	// PerPage The maximum number of items to return in a page of results
	PerPage *PerPageQueryParam `form:"per_page,omitempty" json:"per_page,omitempty"`

	// Page The page token to request from
	Page *PageTokenQueryParam `form:"page,omitempty" json:"page,omitempty"`

	// StateChangeOnly Whether to return the last state change (apply or destroy) deployment for the target environment.
	StateChangeOnly *bool `form:"state_change_only,omitempty" json:"state_change_only,omitempty"`
}

// ListMetadataKeysParams defines parameters for ListMetadataKeys.
type ListMetadataKeysParams struct {
	// PerPage The maximum number of items to return in a page of results
	PerPage *PerPageQueryParam `form:"per_page,omitempty" json:"per_page,omitempty"`

	// Page The page token to request from
	Page *PageTokenQueryParam `form:"page,omitempty" json:"page,omitempty"`
}

// InternalPushMessageToRemoteRunnerJSONRequestBody defines body for InternalPushMessageToRemoteRunner for application/json ContentType.
type InternalPushMessageToRemoteRunnerJSONRequestBody = RemoteRunnerMessage

// CreateDeploymentJSONRequestBody defines body for CreateDeployment for application/json ContentType.
type CreateDeploymentJSONRequestBody = DeploymentCreateBody

// UpdateDeploymentResultsJSONRequestBody defines body for UpdateDeploymentResults for application/json ContentType.
type UpdateDeploymentResultsJSONRequestBody = DeploymentResultsUpdateBody

// CreateMetadataKeyJSONRequestBody defines body for CreateMetadataKey for application/json ContentType.
type CreateMetadataKeyJSONRequestBody = MetadataKeyCreateBody

// UpdateMetadataKeyJSONRequestBody defines body for UpdateMetadataKey for application/json ContentType.
type UpdateMetadataKeyJSONRequestBody = MetadataKeyUpdateBody

// AsRemoteRunnerMessageCreateJob returns the union data inside the RemoteRunnerMessage as a RemoteRunnerMessageCreateJob
func (t RemoteRunnerMessage) AsRemoteRunnerMessageCreateJob() (RemoteRunnerMessageCreateJob, error) {
	var body RemoteRunnerMessageCreateJob
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromRemoteRunnerMessageCreateJob overwrites any union data inside the RemoteRunnerMessage as the provided RemoteRunnerMessageCreateJob
func (t *RemoteRunnerMessage) FromRemoteRunnerMessageCreateJob(v RemoteRunnerMessageCreateJob) error {
	v.Action = "create-job"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeRemoteRunnerMessageCreateJob performs a merge with any union data inside the RemoteRunnerMessage, using the provided RemoteRunnerMessageCreateJob
func (t *RemoteRunnerMessage) MergeRemoteRunnerMessageCreateJob(v RemoteRunnerMessageCreateJob) error {
	v.Action = "create-job"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsRemoteRunnerMessageGetJobStatus returns the union data inside the RemoteRunnerMessage as a RemoteRunnerMessageGetJobStatus
func (t RemoteRunnerMessage) AsRemoteRunnerMessageGetJobStatus() (RemoteRunnerMessageGetJobStatus, error) {
	var body RemoteRunnerMessageGetJobStatus
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromRemoteRunnerMessageGetJobStatus overwrites any union data inside the RemoteRunnerMessage as the provided RemoteRunnerMessageGetJobStatus
func (t *RemoteRunnerMessage) FromRemoteRunnerMessageGetJobStatus(v RemoteRunnerMessageGetJobStatus) error {
	v.Action = "get-job-status"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeRemoteRunnerMessageGetJobStatus performs a merge with any union data inside the RemoteRunnerMessage, using the provided RemoteRunnerMessageGetJobStatus
func (t *RemoteRunnerMessage) MergeRemoteRunnerMessageGetJobStatus(v RemoteRunnerMessageGetJobStatus) error {
	v.Action = "get-job-status"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t RemoteRunnerMessage) Discriminator() (string, error) {
	var discriminator struct {
		Discriminator string `json:"action"`
	}
	err := json.Unmarshal(t.union, &discriminator)
	return discriminator.Discriminator, err
}

func (t RemoteRunnerMessage) ValueByDiscriminator() (interface{}, error) {
	discriminator, err := t.Discriminator()
	if err != nil {
		return nil, err
	}
	switch discriminator {
	case "create-job":
		return t.AsRemoteRunnerMessageCreateJob()
	case "get-job-status":
		return t.AsRemoteRunnerMessageGetJobStatus()
	default:
		return nil, errors.New("unknown discriminator value: " + discriminator)
	}
}

func (t RemoteRunnerMessage) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *RemoteRunnerMessage) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// RequestEditorFn  is the function signature for the RequestEditor callback function
type RequestEditorFn func(ctx context.Context, req *http.Request) error

// Doer performs HTTP requests.
//
// The standard http.Client implements this interface.
type HttpRequestDoer interface {
	Do(req *http.Request) (*http.Response, error)
}

// Client which conforms to the OpenAPI3 specification for this service.
type Client struct {
	// The endpoint of the server conforming to this interface, with scheme,
	// https://api.deepmap.com for example. This can contain a path relative
	// to the server, such as https://api.deepmap.com/dev-test, and all the
	// paths in the swagger spec will be appended to the server.
	Server string

	// Doer for performing requests, typically a *http.Client with any
	// customized settings, such as certificate chains.
	Client HttpRequestDoer

	// A list of callbacks for modifying requests which are generated before sending over
	// the network.
	RequestEditors []RequestEditorFn
}

// ClientOption allows setting custom parameters during construction
type ClientOption func(*Client) error

// Creates a new Client, with reasonable defaults
func NewClient(server string, opts ...ClientOption) (*Client, error) {
	// create a client with sane default values
	client := Client{
		Server: server,
	}
	// mutate client and add all optional params
	for _, o := range opts {
		if err := o(&client); err != nil {
			return nil, err
		}
	}
	// ensure the server URL always has a trailing slash
	if !strings.HasSuffix(client.Server, "/") {
		client.Server += "/"
	}
	// create httpClient, if not already present
	if client.Client == nil {
		client.Client = &http.Client{}
	}
	return &client, nil
}

// WithHTTPClient allows overriding the default Doer, which is
// automatically created using http.Client. This is useful for tests.
func WithHTTPClient(doer HttpRequestDoer) ClientOption {
	return func(c *Client) error {
		c.Client = doer
		return nil
	}
}

// WithRequestEditorFn allows setting up a callback function, which will be
// called right before sending the request. This can be used to mutate the request.
func WithRequestEditorFn(fn RequestEditorFn) ClientOption {
	return func(c *Client) error {
		c.RequestEditors = append(c.RequestEditors, fn)
		return nil
	}
}

// The interface specification for the client above.
type ClientInterface interface {
	// GetJwks request
	GetJwks(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetOpenidConfiguration request
	GetOpenidConfiguration(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// InternalDeleteDeployments request
	InternalDeleteDeployments(ctx context.Context, orgId OrgIdPathParam, params *InternalDeleteDeploymentsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// InternalCheckModuleUsage request
	InternalCheckModuleUsage(ctx context.Context, orgId OrgIdPathParam, moduleId string, params *InternalCheckModuleUsageParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// InternalPushMessageToRemoteRunnerWithBody request with any body
	InternalPushMessageToRemoteRunnerWithBody(ctx context.Context, orgId OrgIdPathParam, runnerId RunnerIdPathParam, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	InternalPushMessageToRemoteRunner(ctx context.Context, orgId OrgIdPathParam, runnerId RunnerIdPathParam, body InternalPushMessageToRemoteRunnerJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListActiveResourceNodes request
	ListActiveResourceNodes(ctx context.Context, orgId OrgIdPathParam, params *ListActiveResourceNodesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListDeployments request
	ListDeployments(ctx context.Context, orgId OrgIdPathParam, params *ListDeploymentsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateDeploymentWithBody request with any body
	CreateDeploymentWithBody(ctx context.Context, orgId OrgIdPathParam, params *CreateDeploymentParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateDeployment(ctx context.Context, orgId OrgIdPathParam, params *CreateDeploymentParams, body CreateDeploymentJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetDeployment request
	GetDeployment(ctx context.Context, orgId OrgIdPathParam, deploymentId DeploymentIdPathParam, reqEditors ...RequestEditorFn) (*http.Response, error)

	// WaitForDeploymentComplete request
	WaitForDeploymentComplete(ctx context.Context, orgId OrgIdPathParam, deploymentId DeploymentIdPathParam, params *WaitForDeploymentCompleteParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetDeploymentBundle request
	GetDeploymentBundle(ctx context.Context, orgId OrgIdPathParam, deploymentId DeploymentIdPathParam, params *GetDeploymentBundleParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetDeploymentEncryptedOutputs request
	GetDeploymentEncryptedOutputs(ctx context.Context, orgId OrgIdPathParam, deploymentId DeploymentIdPathParam, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateDeploymentResultsWithBody request with any body
	UpdateDeploymentResultsWithBody(ctx context.Context, orgId OrgIdPathParam, deploymentId DeploymentIdPathParam, params *UpdateDeploymentResultsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateDeploymentResults(ctx context.Context, orgId OrgIdPathParam, deploymentId DeploymentIdPathParam, params *UpdateDeploymentResultsParams, body UpdateDeploymentResultsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListLastDeployments request
	ListLastDeployments(ctx context.Context, orgId OrgIdPathParam, params *ListLastDeploymentsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListMetadataKeys request
	ListMetadataKeys(ctx context.Context, orgId OrgIdPathParam, params *ListMetadataKeysParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateMetadataKeyWithBody request with any body
	CreateMetadataKeyWithBody(ctx context.Context, orgId OrgIdPathParam, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateMetadataKey(ctx context.Context, orgId OrgIdPathParam, body CreateMetadataKeyJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteMetadataKey request
	DeleteMetadataKey(ctx context.Context, orgId OrgIdPathParam, metadataKeyName MetadataKeyNamePathParam, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetMetadataKey request
	GetMetadataKey(ctx context.Context, orgId OrgIdPathParam, metadataKeyName MetadataKeyNamePathParam, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateMetadataKeyWithBody request with any body
	UpdateMetadataKeyWithBody(ctx context.Context, orgId OrgIdPathParam, metadataKeyName MetadataKeyNamePathParam, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateMetadataKey(ctx context.Context, orgId OrgIdPathParam, metadataKeyName MetadataKeyNamePathParam, body UpdateMetadataKeyJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// WaitForRemoteRunnerMessages request
	WaitForRemoteRunnerMessages(ctx context.Context, orgId OrgIdPathParam, runnerId RunnerIdPathParam, reqEditors ...RequestEditorFn) (*http.Response, error)
}

func (c *Client) GetJwks(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetJwksRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetOpenidConfiguration(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetOpenidConfigurationRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) InternalDeleteDeployments(ctx context.Context, orgId OrgIdPathParam, params *InternalDeleteDeploymentsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewInternalDeleteDeploymentsRequest(c.Server, orgId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) InternalCheckModuleUsage(ctx context.Context, orgId OrgIdPathParam, moduleId string, params *InternalCheckModuleUsageParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewInternalCheckModuleUsageRequest(c.Server, orgId, moduleId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) InternalPushMessageToRemoteRunnerWithBody(ctx context.Context, orgId OrgIdPathParam, runnerId RunnerIdPathParam, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewInternalPushMessageToRemoteRunnerRequestWithBody(c.Server, orgId, runnerId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) InternalPushMessageToRemoteRunner(ctx context.Context, orgId OrgIdPathParam, runnerId RunnerIdPathParam, body InternalPushMessageToRemoteRunnerJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewInternalPushMessageToRemoteRunnerRequest(c.Server, orgId, runnerId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListActiveResourceNodes(ctx context.Context, orgId OrgIdPathParam, params *ListActiveResourceNodesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListActiveResourceNodesRequest(c.Server, orgId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListDeployments(ctx context.Context, orgId OrgIdPathParam, params *ListDeploymentsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListDeploymentsRequest(c.Server, orgId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateDeploymentWithBody(ctx context.Context, orgId OrgIdPathParam, params *CreateDeploymentParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateDeploymentRequestWithBody(c.Server, orgId, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateDeployment(ctx context.Context, orgId OrgIdPathParam, params *CreateDeploymentParams, body CreateDeploymentJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateDeploymentRequest(c.Server, orgId, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetDeployment(ctx context.Context, orgId OrgIdPathParam, deploymentId DeploymentIdPathParam, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetDeploymentRequest(c.Server, orgId, deploymentId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) WaitForDeploymentComplete(ctx context.Context, orgId OrgIdPathParam, deploymentId DeploymentIdPathParam, params *WaitForDeploymentCompleteParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewWaitForDeploymentCompleteRequest(c.Server, orgId, deploymentId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetDeploymentBundle(ctx context.Context, orgId OrgIdPathParam, deploymentId DeploymentIdPathParam, params *GetDeploymentBundleParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetDeploymentBundleRequest(c.Server, orgId, deploymentId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetDeploymentEncryptedOutputs(ctx context.Context, orgId OrgIdPathParam, deploymentId DeploymentIdPathParam, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetDeploymentEncryptedOutputsRequest(c.Server, orgId, deploymentId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateDeploymentResultsWithBody(ctx context.Context, orgId OrgIdPathParam, deploymentId DeploymentIdPathParam, params *UpdateDeploymentResultsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateDeploymentResultsRequestWithBody(c.Server, orgId, deploymentId, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateDeploymentResults(ctx context.Context, orgId OrgIdPathParam, deploymentId DeploymentIdPathParam, params *UpdateDeploymentResultsParams, body UpdateDeploymentResultsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateDeploymentResultsRequest(c.Server, orgId, deploymentId, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListLastDeployments(ctx context.Context, orgId OrgIdPathParam, params *ListLastDeploymentsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListLastDeploymentsRequest(c.Server, orgId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListMetadataKeys(ctx context.Context, orgId OrgIdPathParam, params *ListMetadataKeysParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListMetadataKeysRequest(c.Server, orgId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateMetadataKeyWithBody(ctx context.Context, orgId OrgIdPathParam, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateMetadataKeyRequestWithBody(c.Server, orgId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateMetadataKey(ctx context.Context, orgId OrgIdPathParam, body CreateMetadataKeyJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateMetadataKeyRequest(c.Server, orgId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteMetadataKey(ctx context.Context, orgId OrgIdPathParam, metadataKeyName MetadataKeyNamePathParam, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteMetadataKeyRequest(c.Server, orgId, metadataKeyName)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetMetadataKey(ctx context.Context, orgId OrgIdPathParam, metadataKeyName MetadataKeyNamePathParam, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetMetadataKeyRequest(c.Server, orgId, metadataKeyName)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateMetadataKeyWithBody(ctx context.Context, orgId OrgIdPathParam, metadataKeyName MetadataKeyNamePathParam, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateMetadataKeyRequestWithBody(c.Server, orgId, metadataKeyName, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateMetadataKey(ctx context.Context, orgId OrgIdPathParam, metadataKeyName MetadataKeyNamePathParam, body UpdateMetadataKeyJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateMetadataKeyRequest(c.Server, orgId, metadataKeyName, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) WaitForRemoteRunnerMessages(ctx context.Context, orgId OrgIdPathParam, runnerId RunnerIdPathParam, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewWaitForRemoteRunnerMessagesRequest(c.Server, orgId, runnerId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

// NewGetJwksRequest generates requests for GetJwks
func NewGetJwksRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/.well-known/jwks")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetOpenidConfigurationRequest generates requests for GetOpenidConfiguration
func NewGetOpenidConfigurationRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/.well-known/openid-configuration")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewInternalDeleteDeploymentsRequest generates requests for InternalDeleteDeployments
func NewInternalDeleteDeploymentsRequest(server string, orgId OrgIdPathParam, params *InternalDeleteDeploymentsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "orgId", runtime.ParamLocationPath, orgId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/internal/orgs/%s/deployments", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.ProjectId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "project_id", runtime.ParamLocationQuery, *params.ProjectId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.EnvId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "env_id", runtime.ParamLocationQuery, *params.EnvId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Force != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force", runtime.ParamLocationQuery, *params.Force); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewInternalCheckModuleUsageRequest generates requests for InternalCheckModuleUsage
func NewInternalCheckModuleUsageRequest(server string, orgId OrgIdPathParam, moduleId string, params *InternalCheckModuleUsageParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "orgId", runtime.ParamLocationPath, orgId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "moduleId", runtime.ParamLocationPath, moduleId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/internal/orgs/%s/modules/%s/actions/checkUsage", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.ModuleVersion != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "module_version", runtime.ParamLocationQuery, *params.ModuleVersion); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewInternalPushMessageToRemoteRunnerRequest calls the generic InternalPushMessageToRemoteRunner builder with application/json body
func NewInternalPushMessageToRemoteRunnerRequest(server string, orgId OrgIdPathParam, runnerId RunnerIdPathParam, body InternalPushMessageToRemoteRunnerJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewInternalPushMessageToRemoteRunnerRequestWithBody(server, orgId, runnerId, "application/json", bodyReader)
}

// NewInternalPushMessageToRemoteRunnerRequestWithBody generates requests for InternalPushMessageToRemoteRunner with any type of body
func NewInternalPushMessageToRemoteRunnerRequestWithBody(server string, orgId OrgIdPathParam, runnerId RunnerIdPathParam, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "orgId", runtime.ParamLocationPath, orgId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "runnerId", runtime.ParamLocationPath, runnerId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/internal/orgs/%s/remote-runners/%s/actions/push-message", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewListActiveResourceNodesRequest generates requests for ListActiveResourceNodes
func NewListActiveResourceNodesRequest(server string, orgId OrgIdPathParam, params *ListActiveResourceNodesParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "orgId", runtime.ParamLocationPath, orgId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/orgs/%s/active-resources", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.ProjectId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "project_id", runtime.ParamLocationQuery, *params.ProjectId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.EnvId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "env_id", runtime.ParamLocationQuery, *params.EnvId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListDeploymentsRequest generates requests for ListDeployments
func NewListDeploymentsRequest(server string, orgId OrgIdPathParam, params *ListDeploymentsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "orgId", runtime.ParamLocationPath, orgId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/orgs/%s/deployments", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.ProjectId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "project_id", runtime.ParamLocationQuery, *params.ProjectId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.EnvId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "env_id", runtime.ParamLocationQuery, *params.EnvId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PerPage != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "per_page", runtime.ParamLocationQuery, *params.PerPage); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Page != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateDeploymentRequest calls the generic CreateDeployment builder with application/json body
func NewCreateDeploymentRequest(server string, orgId OrgIdPathParam, params *CreateDeploymentParams, body CreateDeploymentJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateDeploymentRequestWithBody(server, orgId, params, "application/json", bodyReader)
}

// NewCreateDeploymentRequestWithBody generates requests for CreateDeployment with any type of body
func NewCreateDeploymentRequestWithBody(server string, orgId OrgIdPathParam, params *CreateDeploymentParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "orgId", runtime.ParamLocationPath, orgId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/orgs/%s/deployments", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		if params.IdempotencyKey != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Idempotency-Key", runtime.ParamLocationHeader, *params.IdempotencyKey)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Idempotency-Key", headerParam0)
		}

	}

	return req, nil
}

// NewGetDeploymentRequest generates requests for GetDeployment
func NewGetDeploymentRequest(server string, orgId OrgIdPathParam, deploymentId DeploymentIdPathParam) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "orgId", runtime.ParamLocationPath, orgId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "deploymentId", runtime.ParamLocationPath, deploymentId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/orgs/%s/deployments/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewWaitForDeploymentCompleteRequest generates requests for WaitForDeploymentComplete
func NewWaitForDeploymentCompleteRequest(server string, orgId OrgIdPathParam, deploymentId DeploymentIdPathParam, params *WaitForDeploymentCompleteParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "orgId", runtime.ParamLocationPath, orgId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "deploymentId", runtime.ParamLocationPath, deploymentId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/orgs/%s/deployments/%s/actions/waitForComplete", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TimeoutInSeconds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "timeout_in_seconds", runtime.ParamLocationQuery, *params.TimeoutInSeconds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetDeploymentBundleRequest generates requests for GetDeploymentBundle
func NewGetDeploymentBundleRequest(server string, orgId OrgIdPathParam, deploymentId DeploymentIdPathParam, params *GetDeploymentBundleParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "orgId", runtime.ParamLocationPath, orgId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "deploymentId", runtime.ParamLocationPath, deploymentId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/orgs/%s/deployments/%s/bundle", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Deployment-Token", runtime.ParamLocationHeader, params.XDeploymentToken)
		if err != nil {
			return nil, err
		}

		req.Header.Set("X-Deployment-Token", headerParam0)

	}

	return req, nil
}

// NewGetDeploymentEncryptedOutputsRequest generates requests for GetDeploymentEncryptedOutputs
func NewGetDeploymentEncryptedOutputsRequest(server string, orgId OrgIdPathParam, deploymentId DeploymentIdPathParam) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "orgId", runtime.ParamLocationPath, orgId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "deploymentId", runtime.ParamLocationPath, deploymentId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/orgs/%s/deployments/%s/encrypted-outputs", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateDeploymentResultsRequest calls the generic UpdateDeploymentResults builder with application/json body
func NewUpdateDeploymentResultsRequest(server string, orgId OrgIdPathParam, deploymentId DeploymentIdPathParam, params *UpdateDeploymentResultsParams, body UpdateDeploymentResultsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateDeploymentResultsRequestWithBody(server, orgId, deploymentId, params, "application/json", bodyReader)
}

// NewUpdateDeploymentResultsRequestWithBody generates requests for UpdateDeploymentResults with any type of body
func NewUpdateDeploymentResultsRequestWithBody(server string, orgId OrgIdPathParam, deploymentId DeploymentIdPathParam, params *UpdateDeploymentResultsParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "orgId", runtime.ParamLocationPath, orgId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "deploymentId", runtime.ParamLocationPath, deploymentId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/orgs/%s/deployments/%s/results", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Deployment-Token", runtime.ParamLocationHeader, params.XDeploymentToken)
		if err != nil {
			return nil, err
		}

		req.Header.Set("X-Deployment-Token", headerParam0)

	}

	return req, nil
}

// NewListLastDeploymentsRequest generates requests for ListLastDeployments
func NewListLastDeploymentsRequest(server string, orgId OrgIdPathParam, params *ListLastDeploymentsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "orgId", runtime.ParamLocationPath, orgId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/orgs/%s/last-deployments", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.ProjectId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "project_id", runtime.ParamLocationQuery, *params.ProjectId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.EnvId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "env_id", runtime.ParamLocationQuery, *params.EnvId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PerPage != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "per_page", runtime.ParamLocationQuery, *params.PerPage); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Page != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.StateChangeOnly != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "state_change_only", runtime.ParamLocationQuery, *params.StateChangeOnly); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListMetadataKeysRequest generates requests for ListMetadataKeys
func NewListMetadataKeysRequest(server string, orgId OrgIdPathParam, params *ListMetadataKeysParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "orgId", runtime.ParamLocationPath, orgId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/orgs/%s/metadata-keys", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.PerPage != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "per_page", runtime.ParamLocationQuery, *params.PerPage); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Page != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateMetadataKeyRequest calls the generic CreateMetadataKey builder with application/json body
func NewCreateMetadataKeyRequest(server string, orgId OrgIdPathParam, body CreateMetadataKeyJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateMetadataKeyRequestWithBody(server, orgId, "application/json", bodyReader)
}

// NewCreateMetadataKeyRequestWithBody generates requests for CreateMetadataKey with any type of body
func NewCreateMetadataKeyRequestWithBody(server string, orgId OrgIdPathParam, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "orgId", runtime.ParamLocationPath, orgId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/orgs/%s/metadata-keys", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteMetadataKeyRequest generates requests for DeleteMetadataKey
func NewDeleteMetadataKeyRequest(server string, orgId OrgIdPathParam, metadataKeyName MetadataKeyNamePathParam) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "orgId", runtime.ParamLocationPath, orgId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "metadataKeyName", runtime.ParamLocationPath, metadataKeyName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/orgs/%s/metadata-keys/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetMetadataKeyRequest generates requests for GetMetadataKey
func NewGetMetadataKeyRequest(server string, orgId OrgIdPathParam, metadataKeyName MetadataKeyNamePathParam) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "orgId", runtime.ParamLocationPath, orgId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "metadataKeyName", runtime.ParamLocationPath, metadataKeyName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/orgs/%s/metadata-keys/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateMetadataKeyRequest calls the generic UpdateMetadataKey builder with application/json body
func NewUpdateMetadataKeyRequest(server string, orgId OrgIdPathParam, metadataKeyName MetadataKeyNamePathParam, body UpdateMetadataKeyJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateMetadataKeyRequestWithBody(server, orgId, metadataKeyName, "application/json", bodyReader)
}

// NewUpdateMetadataKeyRequestWithBody generates requests for UpdateMetadataKey with any type of body
func NewUpdateMetadataKeyRequestWithBody(server string, orgId OrgIdPathParam, metadataKeyName MetadataKeyNamePathParam, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "orgId", runtime.ParamLocationPath, orgId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "metadataKeyName", runtime.ParamLocationPath, metadataKeyName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/orgs/%s/metadata-keys/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewWaitForRemoteRunnerMessagesRequest generates requests for WaitForRemoteRunnerMessages
func NewWaitForRemoteRunnerMessagesRequest(server string, orgId OrgIdPathParam, runnerId RunnerIdPathParam) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "orgId", runtime.ParamLocationPath, orgId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "runnerId", runtime.ParamLocationPath, runnerId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/orgs/%s/remote-runners/%s/actions/poll-requests", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

func (c *Client) applyEditors(ctx context.Context, req *http.Request, additionalEditors []RequestEditorFn) error {
	for _, r := range c.RequestEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	for _, r := range additionalEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	return nil
}

// ClientWithResponses builds on ClientInterface to offer response payloads
type ClientWithResponses struct {
	ClientInterface
}

// NewClientWithResponses creates a new ClientWithResponses, which wraps
// Client with return type handling
func NewClientWithResponses(server string, opts ...ClientOption) (*ClientWithResponses, error) {
	client, err := NewClient(server, opts...)
	if err != nil {
		return nil, err
	}
	return &ClientWithResponses{client}, nil
}

// WithBaseURL overrides the baseURL.
func WithBaseURL(baseURL string) ClientOption {
	return func(c *Client) error {
		newBaseURL, err := url.Parse(baseURL)
		if err != nil {
			return err
		}
		c.Server = newBaseURL.String()
		return nil
	}
}

// ClientWithResponsesInterface is the interface specification for the client with responses above.
type ClientWithResponsesInterface interface {
	// GetJwksWithResponse request
	GetJwksWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetJwksResponse, error)

	// GetOpenidConfigurationWithResponse request
	GetOpenidConfigurationWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetOpenidConfigurationResponse, error)

	// InternalDeleteDeploymentsWithResponse request
	InternalDeleteDeploymentsWithResponse(ctx context.Context, orgId OrgIdPathParam, params *InternalDeleteDeploymentsParams, reqEditors ...RequestEditorFn) (*InternalDeleteDeploymentsResponse, error)

	// InternalCheckModuleUsageWithResponse request
	InternalCheckModuleUsageWithResponse(ctx context.Context, orgId OrgIdPathParam, moduleId string, params *InternalCheckModuleUsageParams, reqEditors ...RequestEditorFn) (*InternalCheckModuleUsageResponse, error)

	// InternalPushMessageToRemoteRunnerWithBodyWithResponse request with any body
	InternalPushMessageToRemoteRunnerWithBodyWithResponse(ctx context.Context, orgId OrgIdPathParam, runnerId RunnerIdPathParam, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*InternalPushMessageToRemoteRunnerResponse, error)

	InternalPushMessageToRemoteRunnerWithResponse(ctx context.Context, orgId OrgIdPathParam, runnerId RunnerIdPathParam, body InternalPushMessageToRemoteRunnerJSONRequestBody, reqEditors ...RequestEditorFn) (*InternalPushMessageToRemoteRunnerResponse, error)

	// ListActiveResourceNodesWithResponse request
	ListActiveResourceNodesWithResponse(ctx context.Context, orgId OrgIdPathParam, params *ListActiveResourceNodesParams, reqEditors ...RequestEditorFn) (*ListActiveResourceNodesResponse, error)

	// ListDeploymentsWithResponse request
	ListDeploymentsWithResponse(ctx context.Context, orgId OrgIdPathParam, params *ListDeploymentsParams, reqEditors ...RequestEditorFn) (*ListDeploymentsResponse, error)

	// CreateDeploymentWithBodyWithResponse request with any body
	CreateDeploymentWithBodyWithResponse(ctx context.Context, orgId OrgIdPathParam, params *CreateDeploymentParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateDeploymentResponse, error)

	CreateDeploymentWithResponse(ctx context.Context, orgId OrgIdPathParam, params *CreateDeploymentParams, body CreateDeploymentJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateDeploymentResponse, error)

	// GetDeploymentWithResponse request
	GetDeploymentWithResponse(ctx context.Context, orgId OrgIdPathParam, deploymentId DeploymentIdPathParam, reqEditors ...RequestEditorFn) (*GetDeploymentResponse, error)

	// WaitForDeploymentCompleteWithResponse request
	WaitForDeploymentCompleteWithResponse(ctx context.Context, orgId OrgIdPathParam, deploymentId DeploymentIdPathParam, params *WaitForDeploymentCompleteParams, reqEditors ...RequestEditorFn) (*WaitForDeploymentCompleteResponse, error)

	// GetDeploymentBundleWithResponse request
	GetDeploymentBundleWithResponse(ctx context.Context, orgId OrgIdPathParam, deploymentId DeploymentIdPathParam, params *GetDeploymentBundleParams, reqEditors ...RequestEditorFn) (*GetDeploymentBundleResponse, error)

	// GetDeploymentEncryptedOutputsWithResponse request
	GetDeploymentEncryptedOutputsWithResponse(ctx context.Context, orgId OrgIdPathParam, deploymentId DeploymentIdPathParam, reqEditors ...RequestEditorFn) (*GetDeploymentEncryptedOutputsResponse, error)

	// UpdateDeploymentResultsWithBodyWithResponse request with any body
	UpdateDeploymentResultsWithBodyWithResponse(ctx context.Context, orgId OrgIdPathParam, deploymentId DeploymentIdPathParam, params *UpdateDeploymentResultsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateDeploymentResultsResponse, error)

	UpdateDeploymentResultsWithResponse(ctx context.Context, orgId OrgIdPathParam, deploymentId DeploymentIdPathParam, params *UpdateDeploymentResultsParams, body UpdateDeploymentResultsJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateDeploymentResultsResponse, error)

	// ListLastDeploymentsWithResponse request
	ListLastDeploymentsWithResponse(ctx context.Context, orgId OrgIdPathParam, params *ListLastDeploymentsParams, reqEditors ...RequestEditorFn) (*ListLastDeploymentsResponse, error)

	// ListMetadataKeysWithResponse request
	ListMetadataKeysWithResponse(ctx context.Context, orgId OrgIdPathParam, params *ListMetadataKeysParams, reqEditors ...RequestEditorFn) (*ListMetadataKeysResponse, error)

	// CreateMetadataKeyWithBodyWithResponse request with any body
	CreateMetadataKeyWithBodyWithResponse(ctx context.Context, orgId OrgIdPathParam, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateMetadataKeyResponse, error)

	CreateMetadataKeyWithResponse(ctx context.Context, orgId OrgIdPathParam, body CreateMetadataKeyJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateMetadataKeyResponse, error)

	// DeleteMetadataKeyWithResponse request
	DeleteMetadataKeyWithResponse(ctx context.Context, orgId OrgIdPathParam, metadataKeyName MetadataKeyNamePathParam, reqEditors ...RequestEditorFn) (*DeleteMetadataKeyResponse, error)

	// GetMetadataKeyWithResponse request
	GetMetadataKeyWithResponse(ctx context.Context, orgId OrgIdPathParam, metadataKeyName MetadataKeyNamePathParam, reqEditors ...RequestEditorFn) (*GetMetadataKeyResponse, error)

	// UpdateMetadataKeyWithBodyWithResponse request with any body
	UpdateMetadataKeyWithBodyWithResponse(ctx context.Context, orgId OrgIdPathParam, metadataKeyName MetadataKeyNamePathParam, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateMetadataKeyResponse, error)

	UpdateMetadataKeyWithResponse(ctx context.Context, orgId OrgIdPathParam, metadataKeyName MetadataKeyNamePathParam, body UpdateMetadataKeyJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateMetadataKeyResponse, error)

	// WaitForRemoteRunnerMessagesWithResponse request
	WaitForRemoteRunnerMessagesWithResponse(ctx context.Context, orgId OrgIdPathParam, runnerId RunnerIdPathParam, reqEditors ...RequestEditorFn) (*WaitForRemoteRunnerMessagesResponse, error)
}

type GetJwksResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Jwks
}

// Status returns HTTPResponse.Status
func (r GetJwksResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetJwksResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetOpenidConfigurationResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *OpenidConfiguration
}

// Status returns HTTPResponse.Status
func (r GetOpenidConfigurationResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetOpenidConfigurationResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type InternalDeleteDeploymentsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *N400BadRequest
	JSON404      *N404NotFound
	JSON409      *N409Conflict
}

// Status returns HTTPResponse.Status
func (r InternalDeleteDeploymentsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r InternalDeleteDeploymentsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type InternalCheckModuleUsageResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *InternalModuleUsage
	JSON404      *N404NotFound
}

// Status returns HTTPResponse.Status
func (r InternalCheckModuleUsageResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r InternalCheckModuleUsageResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type InternalPushMessageToRemoteRunnerResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r InternalPushMessageToRemoteRunnerResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r InternalPushMessageToRemoteRunnerResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListActiveResourceNodesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ListActiveResourceNodesPage
	JSON400      *N400BadRequest
	JSON404      *N404NotFound
}

// Status returns HTTPResponse.Status
func (r ListActiveResourceNodesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListActiveResourceNodesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListDeploymentsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *DeploymentPage
	JSON400      *N400BadRequest
	JSON404      *N404NotFound
}

// Status returns HTTPResponse.Status
func (r ListDeploymentsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListDeploymentsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateDeploymentResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *DeploymentDryRun
	JSON201      *Deployment
	JSON400      *N400BadRequest
	JSON409      *N409Conflict
}

// Status returns HTTPResponse.Status
func (r CreateDeploymentResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateDeploymentResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetDeploymentResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Deployment
	JSON404      *N404NotFound
}

// Status returns HTTPResponse.Status
func (r GetDeploymentResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetDeploymentResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type WaitForDeploymentCompleteResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Deployment
	JSON404      *N404NotFound
	JSON408      *Error
}

// Status returns HTTPResponse.Status
func (r WaitForDeploymentCompleteResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r WaitForDeploymentCompleteResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetDeploymentBundleResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *N400BadRequest
	JSON404      *N404NotFound
}

// Status returns HTTPResponse.Status
func (r GetDeploymentBundleResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetDeploymentBundleResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetDeploymentEncryptedOutputsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *DeploymentEncryptedOutputs
	JSON404      *N404NotFound
}

// Status returns HTTPResponse.Status
func (r GetDeploymentEncryptedOutputsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetDeploymentEncryptedOutputsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateDeploymentResultsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *N400BadRequest
	JSON404      *N404NotFound
	JSON409      *N409Conflict
}

// Status returns HTTPResponse.Status
func (r UpdateDeploymentResultsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateDeploymentResultsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListLastDeploymentsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *DeploymentPage
	JSON400      *N400BadRequest
	JSON404      *N404NotFound
}

// Status returns HTTPResponse.Status
func (r ListLastDeploymentsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListLastDeploymentsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListMetadataKeysResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *MetadataKeyPage
	JSON404      *N404NotFound
}

// Status returns HTTPResponse.Status
func (r ListMetadataKeysResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListMetadataKeysResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateMetadataKeyResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *MetadataKey
	JSON400      *N400BadRequest
	JSON404      *N404NotFound
}

// Status returns HTTPResponse.Status
func (r CreateMetadataKeyResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateMetadataKeyResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteMetadataKeyResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON404      *N404NotFound
}

// Status returns HTTPResponse.Status
func (r DeleteMetadataKeyResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteMetadataKeyResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetMetadataKeyResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *MetadataKey
	JSON404      *N404NotFound
}

// Status returns HTTPResponse.Status
func (r GetMetadataKeyResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetMetadataKeyResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateMetadataKeyResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *MetadataKey
	JSON400      *N400BadRequest
	JSON404      *N404NotFound
}

// Status returns HTTPResponse.Status
func (r UpdateMetadataKeyResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateMetadataKeyResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type WaitForRemoteRunnerMessagesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RemoteRunnerMessage
	JSON404      *N404NotFound
}

// Status returns HTTPResponse.Status
func (r WaitForRemoteRunnerMessagesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r WaitForRemoteRunnerMessagesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// GetJwksWithResponse request returning *GetJwksResponse
func (c *ClientWithResponses) GetJwksWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetJwksResponse, error) {
	rsp, err := c.GetJwks(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetJwksResponse(rsp)
}

// GetOpenidConfigurationWithResponse request returning *GetOpenidConfigurationResponse
func (c *ClientWithResponses) GetOpenidConfigurationWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetOpenidConfigurationResponse, error) {
	rsp, err := c.GetOpenidConfiguration(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetOpenidConfigurationResponse(rsp)
}

// InternalDeleteDeploymentsWithResponse request returning *InternalDeleteDeploymentsResponse
func (c *ClientWithResponses) InternalDeleteDeploymentsWithResponse(ctx context.Context, orgId OrgIdPathParam, params *InternalDeleteDeploymentsParams, reqEditors ...RequestEditorFn) (*InternalDeleteDeploymentsResponse, error) {
	rsp, err := c.InternalDeleteDeployments(ctx, orgId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseInternalDeleteDeploymentsResponse(rsp)
}

// InternalCheckModuleUsageWithResponse request returning *InternalCheckModuleUsageResponse
func (c *ClientWithResponses) InternalCheckModuleUsageWithResponse(ctx context.Context, orgId OrgIdPathParam, moduleId string, params *InternalCheckModuleUsageParams, reqEditors ...RequestEditorFn) (*InternalCheckModuleUsageResponse, error) {
	rsp, err := c.InternalCheckModuleUsage(ctx, orgId, moduleId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseInternalCheckModuleUsageResponse(rsp)
}

// InternalPushMessageToRemoteRunnerWithBodyWithResponse request with arbitrary body returning *InternalPushMessageToRemoteRunnerResponse
func (c *ClientWithResponses) InternalPushMessageToRemoteRunnerWithBodyWithResponse(ctx context.Context, orgId OrgIdPathParam, runnerId RunnerIdPathParam, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*InternalPushMessageToRemoteRunnerResponse, error) {
	rsp, err := c.InternalPushMessageToRemoteRunnerWithBody(ctx, orgId, runnerId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseInternalPushMessageToRemoteRunnerResponse(rsp)
}

func (c *ClientWithResponses) InternalPushMessageToRemoteRunnerWithResponse(ctx context.Context, orgId OrgIdPathParam, runnerId RunnerIdPathParam, body InternalPushMessageToRemoteRunnerJSONRequestBody, reqEditors ...RequestEditorFn) (*InternalPushMessageToRemoteRunnerResponse, error) {
	rsp, err := c.InternalPushMessageToRemoteRunner(ctx, orgId, runnerId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseInternalPushMessageToRemoteRunnerResponse(rsp)
}

// ListActiveResourceNodesWithResponse request returning *ListActiveResourceNodesResponse
func (c *ClientWithResponses) ListActiveResourceNodesWithResponse(ctx context.Context, orgId OrgIdPathParam, params *ListActiveResourceNodesParams, reqEditors ...RequestEditorFn) (*ListActiveResourceNodesResponse, error) {
	rsp, err := c.ListActiveResourceNodes(ctx, orgId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListActiveResourceNodesResponse(rsp)
}

// ListDeploymentsWithResponse request returning *ListDeploymentsResponse
func (c *ClientWithResponses) ListDeploymentsWithResponse(ctx context.Context, orgId OrgIdPathParam, params *ListDeploymentsParams, reqEditors ...RequestEditorFn) (*ListDeploymentsResponse, error) {
	rsp, err := c.ListDeployments(ctx, orgId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListDeploymentsResponse(rsp)
}

// CreateDeploymentWithBodyWithResponse request with arbitrary body returning *CreateDeploymentResponse
func (c *ClientWithResponses) CreateDeploymentWithBodyWithResponse(ctx context.Context, orgId OrgIdPathParam, params *CreateDeploymentParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateDeploymentResponse, error) {
	rsp, err := c.CreateDeploymentWithBody(ctx, orgId, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateDeploymentResponse(rsp)
}

func (c *ClientWithResponses) CreateDeploymentWithResponse(ctx context.Context, orgId OrgIdPathParam, params *CreateDeploymentParams, body CreateDeploymentJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateDeploymentResponse, error) {
	rsp, err := c.CreateDeployment(ctx, orgId, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateDeploymentResponse(rsp)
}

// GetDeploymentWithResponse request returning *GetDeploymentResponse
func (c *ClientWithResponses) GetDeploymentWithResponse(ctx context.Context, orgId OrgIdPathParam, deploymentId DeploymentIdPathParam, reqEditors ...RequestEditorFn) (*GetDeploymentResponse, error) {
	rsp, err := c.GetDeployment(ctx, orgId, deploymentId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetDeploymentResponse(rsp)
}

// WaitForDeploymentCompleteWithResponse request returning *WaitForDeploymentCompleteResponse
func (c *ClientWithResponses) WaitForDeploymentCompleteWithResponse(ctx context.Context, orgId OrgIdPathParam, deploymentId DeploymentIdPathParam, params *WaitForDeploymentCompleteParams, reqEditors ...RequestEditorFn) (*WaitForDeploymentCompleteResponse, error) {
	rsp, err := c.WaitForDeploymentComplete(ctx, orgId, deploymentId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseWaitForDeploymentCompleteResponse(rsp)
}

// GetDeploymentBundleWithResponse request returning *GetDeploymentBundleResponse
func (c *ClientWithResponses) GetDeploymentBundleWithResponse(ctx context.Context, orgId OrgIdPathParam, deploymentId DeploymentIdPathParam, params *GetDeploymentBundleParams, reqEditors ...RequestEditorFn) (*GetDeploymentBundleResponse, error) {
	rsp, err := c.GetDeploymentBundle(ctx, orgId, deploymentId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetDeploymentBundleResponse(rsp)
}

// GetDeploymentEncryptedOutputsWithResponse request returning *GetDeploymentEncryptedOutputsResponse
func (c *ClientWithResponses) GetDeploymentEncryptedOutputsWithResponse(ctx context.Context, orgId OrgIdPathParam, deploymentId DeploymentIdPathParam, reqEditors ...RequestEditorFn) (*GetDeploymentEncryptedOutputsResponse, error) {
	rsp, err := c.GetDeploymentEncryptedOutputs(ctx, orgId, deploymentId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetDeploymentEncryptedOutputsResponse(rsp)
}

// UpdateDeploymentResultsWithBodyWithResponse request with arbitrary body returning *UpdateDeploymentResultsResponse
func (c *ClientWithResponses) UpdateDeploymentResultsWithBodyWithResponse(ctx context.Context, orgId OrgIdPathParam, deploymentId DeploymentIdPathParam, params *UpdateDeploymentResultsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateDeploymentResultsResponse, error) {
	rsp, err := c.UpdateDeploymentResultsWithBody(ctx, orgId, deploymentId, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateDeploymentResultsResponse(rsp)
}

func (c *ClientWithResponses) UpdateDeploymentResultsWithResponse(ctx context.Context, orgId OrgIdPathParam, deploymentId DeploymentIdPathParam, params *UpdateDeploymentResultsParams, body UpdateDeploymentResultsJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateDeploymentResultsResponse, error) {
	rsp, err := c.UpdateDeploymentResults(ctx, orgId, deploymentId, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateDeploymentResultsResponse(rsp)
}

// ListLastDeploymentsWithResponse request returning *ListLastDeploymentsResponse
func (c *ClientWithResponses) ListLastDeploymentsWithResponse(ctx context.Context, orgId OrgIdPathParam, params *ListLastDeploymentsParams, reqEditors ...RequestEditorFn) (*ListLastDeploymentsResponse, error) {
	rsp, err := c.ListLastDeployments(ctx, orgId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListLastDeploymentsResponse(rsp)
}

// ListMetadataKeysWithResponse request returning *ListMetadataKeysResponse
func (c *ClientWithResponses) ListMetadataKeysWithResponse(ctx context.Context, orgId OrgIdPathParam, params *ListMetadataKeysParams, reqEditors ...RequestEditorFn) (*ListMetadataKeysResponse, error) {
	rsp, err := c.ListMetadataKeys(ctx, orgId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListMetadataKeysResponse(rsp)
}

// CreateMetadataKeyWithBodyWithResponse request with arbitrary body returning *CreateMetadataKeyResponse
func (c *ClientWithResponses) CreateMetadataKeyWithBodyWithResponse(ctx context.Context, orgId OrgIdPathParam, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateMetadataKeyResponse, error) {
	rsp, err := c.CreateMetadataKeyWithBody(ctx, orgId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateMetadataKeyResponse(rsp)
}

func (c *ClientWithResponses) CreateMetadataKeyWithResponse(ctx context.Context, orgId OrgIdPathParam, body CreateMetadataKeyJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateMetadataKeyResponse, error) {
	rsp, err := c.CreateMetadataKey(ctx, orgId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateMetadataKeyResponse(rsp)
}

// DeleteMetadataKeyWithResponse request returning *DeleteMetadataKeyResponse
func (c *ClientWithResponses) DeleteMetadataKeyWithResponse(ctx context.Context, orgId OrgIdPathParam, metadataKeyName MetadataKeyNamePathParam, reqEditors ...RequestEditorFn) (*DeleteMetadataKeyResponse, error) {
	rsp, err := c.DeleteMetadataKey(ctx, orgId, metadataKeyName, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteMetadataKeyResponse(rsp)
}

// GetMetadataKeyWithResponse request returning *GetMetadataKeyResponse
func (c *ClientWithResponses) GetMetadataKeyWithResponse(ctx context.Context, orgId OrgIdPathParam, metadataKeyName MetadataKeyNamePathParam, reqEditors ...RequestEditorFn) (*GetMetadataKeyResponse, error) {
	rsp, err := c.GetMetadataKey(ctx, orgId, metadataKeyName, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetMetadataKeyResponse(rsp)
}

// UpdateMetadataKeyWithBodyWithResponse request with arbitrary body returning *UpdateMetadataKeyResponse
func (c *ClientWithResponses) UpdateMetadataKeyWithBodyWithResponse(ctx context.Context, orgId OrgIdPathParam, metadataKeyName MetadataKeyNamePathParam, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateMetadataKeyResponse, error) {
	rsp, err := c.UpdateMetadataKeyWithBody(ctx, orgId, metadataKeyName, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateMetadataKeyResponse(rsp)
}

func (c *ClientWithResponses) UpdateMetadataKeyWithResponse(ctx context.Context, orgId OrgIdPathParam, metadataKeyName MetadataKeyNamePathParam, body UpdateMetadataKeyJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateMetadataKeyResponse, error) {
	rsp, err := c.UpdateMetadataKey(ctx, orgId, metadataKeyName, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateMetadataKeyResponse(rsp)
}

// WaitForRemoteRunnerMessagesWithResponse request returning *WaitForRemoteRunnerMessagesResponse
func (c *ClientWithResponses) WaitForRemoteRunnerMessagesWithResponse(ctx context.Context, orgId OrgIdPathParam, runnerId RunnerIdPathParam, reqEditors ...RequestEditorFn) (*WaitForRemoteRunnerMessagesResponse, error) {
	rsp, err := c.WaitForRemoteRunnerMessages(ctx, orgId, runnerId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseWaitForRemoteRunnerMessagesResponse(rsp)
}

// ParseGetJwksResponse parses an HTTP response from a GetJwksWithResponse call
func ParseGetJwksResponse(rsp *http.Response) (*GetJwksResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetJwksResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Jwks
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetOpenidConfigurationResponse parses an HTTP response from a GetOpenidConfigurationWithResponse call
func ParseGetOpenidConfigurationResponse(rsp *http.Response) (*GetOpenidConfigurationResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetOpenidConfigurationResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest OpenidConfiguration
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseInternalDeleteDeploymentsResponse parses an HTTP response from a InternalDeleteDeploymentsWithResponse call
func ParseInternalDeleteDeploymentsResponse(rsp *http.Response) (*InternalDeleteDeploymentsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &InternalDeleteDeploymentsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest N404NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest N409Conflict
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	}

	return response, nil
}

// ParseInternalCheckModuleUsageResponse parses an HTTP response from a InternalCheckModuleUsageWithResponse call
func ParseInternalCheckModuleUsageResponse(rsp *http.Response) (*InternalCheckModuleUsageResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &InternalCheckModuleUsageResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest InternalModuleUsage
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest N404NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseInternalPushMessageToRemoteRunnerResponse parses an HTTP response from a InternalPushMessageToRemoteRunnerWithResponse call
func ParseInternalPushMessageToRemoteRunnerResponse(rsp *http.Response) (*InternalPushMessageToRemoteRunnerResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &InternalPushMessageToRemoteRunnerResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseListActiveResourceNodesResponse parses an HTTP response from a ListActiveResourceNodesWithResponse call
func ParseListActiveResourceNodesResponse(rsp *http.Response) (*ListActiveResourceNodesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListActiveResourceNodesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ListActiveResourceNodesPage
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest N404NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseListDeploymentsResponse parses an HTTP response from a ListDeploymentsWithResponse call
func ParseListDeploymentsResponse(rsp *http.Response) (*ListDeploymentsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListDeploymentsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest DeploymentPage
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest N404NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseCreateDeploymentResponse parses an HTTP response from a CreateDeploymentWithResponse call
func ParseCreateDeploymentResponse(rsp *http.Response) (*CreateDeploymentResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateDeploymentResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest DeploymentDryRun
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest Deployment
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest N409Conflict
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	}

	return response, nil
}

// ParseGetDeploymentResponse parses an HTTP response from a GetDeploymentWithResponse call
func ParseGetDeploymentResponse(rsp *http.Response) (*GetDeploymentResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetDeploymentResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Deployment
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest N404NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseWaitForDeploymentCompleteResponse parses an HTTP response from a WaitForDeploymentCompleteWithResponse call
func ParseWaitForDeploymentCompleteResponse(rsp *http.Response) (*WaitForDeploymentCompleteResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &WaitForDeploymentCompleteResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Deployment
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest N404NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 408:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON408 = &dest

	}

	return response, nil
}

// ParseGetDeploymentBundleResponse parses an HTTP response from a GetDeploymentBundleWithResponse call
func ParseGetDeploymentBundleResponse(rsp *http.Response) (*GetDeploymentBundleResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetDeploymentBundleResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest N404NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseGetDeploymentEncryptedOutputsResponse parses an HTTP response from a GetDeploymentEncryptedOutputsWithResponse call
func ParseGetDeploymentEncryptedOutputsResponse(rsp *http.Response) (*GetDeploymentEncryptedOutputsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetDeploymentEncryptedOutputsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest DeploymentEncryptedOutputs
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest N404NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseUpdateDeploymentResultsResponse parses an HTTP response from a UpdateDeploymentResultsWithResponse call
func ParseUpdateDeploymentResultsResponse(rsp *http.Response) (*UpdateDeploymentResultsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateDeploymentResultsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest N404NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest N409Conflict
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	}

	return response, nil
}

// ParseListLastDeploymentsResponse parses an HTTP response from a ListLastDeploymentsWithResponse call
func ParseListLastDeploymentsResponse(rsp *http.Response) (*ListLastDeploymentsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListLastDeploymentsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest DeploymentPage
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest N404NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseListMetadataKeysResponse parses an HTTP response from a ListMetadataKeysWithResponse call
func ParseListMetadataKeysResponse(rsp *http.Response) (*ListMetadataKeysResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListMetadataKeysResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest MetadataKeyPage
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest N404NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseCreateMetadataKeyResponse parses an HTTP response from a CreateMetadataKeyWithResponse call
func ParseCreateMetadataKeyResponse(rsp *http.Response) (*CreateMetadataKeyResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateMetadataKeyResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest MetadataKey
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest N404NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseDeleteMetadataKeyResponse parses an HTTP response from a DeleteMetadataKeyWithResponse call
func ParseDeleteMetadataKeyResponse(rsp *http.Response) (*DeleteMetadataKeyResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteMetadataKeyResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest N404NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseGetMetadataKeyResponse parses an HTTP response from a GetMetadataKeyWithResponse call
func ParseGetMetadataKeyResponse(rsp *http.Response) (*GetMetadataKeyResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetMetadataKeyResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest MetadataKey
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest N404NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseUpdateMetadataKeyResponse parses an HTTP response from a UpdateMetadataKeyWithResponse call
func ParseUpdateMetadataKeyResponse(rsp *http.Response) (*UpdateMetadataKeyResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateMetadataKeyResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest MetadataKey
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest N404NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseWaitForRemoteRunnerMessagesResponse parses an HTTP response from a WaitForRemoteRunnerMessagesWithResponse call
func ParseWaitForRemoteRunnerMessagesResponse(rsp *http.Response) (*WaitForRemoteRunnerMessagesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &WaitForRemoteRunnerMessagesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RemoteRunnerMessage
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest N404NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}
