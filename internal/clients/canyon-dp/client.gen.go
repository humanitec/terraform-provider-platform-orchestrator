// Package canyondp provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/oapi-codegen/oapi-codegen/v2 version v2.4.1 DO NOT EDIT.
package canyondp

import (
	"bytes"
	"context"
	"encoding/json"
	"errors"
	"fmt"
	"io"
	"net/http"
	"net/url"
	"strings"
	"time"

	"github.com/oapi-codegen/runtime"
	openapi_types "github.com/oapi-codegen/runtime/types"
)

const (
	JwtAuthScopes      = "jwtAuth.Scopes"
	UserIdHeaderScopes = "userIdHeader.Scopes"
)

// Defines values for DeploymentCreateBodyMode.
const (
	Deploy   DeploymentCreateBodyMode = "deploy"
	PlanOnly DeploymentCreateBodyMode = "plan_only"
)

// Defines values for DeploymentCreateBodyRunnerLogLevel.
const (
	DeploymentCreateBodyRunnerLogLevelDebug DeploymentCreateBodyRunnerLogLevel = "debug"
	DeploymentCreateBodyRunnerLogLevelError DeploymentCreateBodyRunnerLogLevel = "error"
	DeploymentCreateBodyRunnerLogLevelInfo  DeploymentCreateBodyRunnerLogLevel = "info"
	DeploymentCreateBodyRunnerLogLevelWarn  DeploymentCreateBodyRunnerLogLevel = "warn"
)

// Defines values for DeploymentResultsUpdateBodyStatus.
const (
	Failure DeploymentResultsUpdateBodyStatus = "failure"
	Success DeploymentResultsUpdateBodyStatus = "success"
)

// Defines values for MetadataKeySchemaType.
const (
	MetadataKeySchemaTypeString MetadataKeySchemaType = "string"
)

// Defines values for RemoteRunnerMessageAction.
const (
	CheckJobStatus RemoteRunnerMessageAction = "check-job-status"
	CreateJob      RemoteRunnerMessageAction = "create-job"
)

// Defines values for UpdateMetadataKeySchemaType.
const (
	UpdateMetadataKeySchemaTypeString UpdateMetadataKeySchemaType = "string"
)

// ActiveResourceNode A node in the active resource graph
type ActiveResourceNode struct {
	DeploymentId openapi_types.UUID `json:"deployment_id"`
	Edges        map[string]string  `json:"edges"`

	// EnvId The environment id.
	EnvId string `json:"env_id"`

	// Id The deterministic hash of the node in the graph. This hash is also used in the edges map for each node.
	Id            string                 `json:"id"`
	Metadata      map[string]interface{} `json:"metadata"`
	ModuleId      string                 `json:"module_id"`
	ModuleVersion string                 `json:"module_version"`

	// ProjectId The Project id of the environment of this node.
	ProjectId     string `json:"project_id"`
	ResourceClass string `json:"resource_class"`
	ResourceId    string `json:"resource_id"`
	ResourceType  string `json:"resource_type"`
}

// Deployment defines model for Deployment.
type Deployment struct {
	// CompletedAt The time the deployment succeeded, failed, or terminated
	CompletedAt *time.Time `json:"completed_at,omitempty"`

	// CreatedAt The time the deployment was created
	CreatedAt time.Time `json:"created_at"`

	// CreatedBy The user that created the deployment
	CreatedBy openapi_types.UUID `json:"created_by"`

	// EnvId The Environment id in the project which is being deployed
	EnvId string `json:"env_id"`

	// Id The unique deployment id
	Id DeploymentId `json:"id"`

	// Manifest The manifest associated with a deployment
	Manifest DeploymentManifest `json:"manifest"`

	// Metrics Metrics resulting from a deployment.
	Metrics DeploymentMetrics `json:"metrics"`

	// Mode The mode of the deployment.
	Mode string `json:"mode"`

	// OrgId The Organization ID
	OrgId OrganizationId `json:"org_id"`

	// ProjectId The Project id which the environment exists in
	ProjectId string `json:"project_id"`

	// RunnerId The Runner ID that this deployment executes on
	RunnerId string `json:"runner_id"`

	// Status The status of the deployment.
	Status string `json:"status"`

	// StatusMessage A message associated with the 'status'.
	StatusMessage string `json:"status_message"`
}

// DeploymentCreateBody defines model for DeploymentCreateBody.
type DeploymentCreateBody struct {
	// EncryptedLogsRecipient A recipient public key must be provided in order to encrypt the logs produced by the runner. This must be an 'age' public key (see https://age-encryption.org).
	// The caller must hold the matching private key in order to decrypt the logs when the logs url is provided. If the recipient key is not set, no logs will be captured
	// by the runner.
	EncryptedLogsRecipient *string `json:"encrypted_logs_recipient,omitempty"`

	// EncryptedOutputsRecipient A recipient public key must be provided in order to access encrypted outputs of the deployment. This must be an 'age' public key (see https://age-encryption.org).
	// The caller must hold the matching private key in order to decrypt the outputs when the deployment completes. If the recipient key is not set, no outputs will be captured
	// from the deployment.
	EncryptedOutputsRecipient *string `json:"encrypted_outputs_recipient,omitempty"`

	// EnvId The environment to deploy to.
	EnvId string `json:"env_id"`

	// IsDryRun Whether to just validate the request and not persist or execute it.
	IsDryRun bool `json:"is_dry_run,omitempty"`

	// Manifest The manifest associated with a deployment
	Manifest DeploymentManifest `json:"manifest"`

	// Mode The mode of the deployment. Defaults to 'deploy'. Can be set to 'plan_only' to test and validate a deployment.
	Mode DeploymentCreateBodyMode `json:"mode"`

	// ProjectId The Project to deploy to.
	ProjectId string `json:"project_id"`

	// RunnerLogLevel The log level for the runner.
	RunnerLogLevel *DeploymentCreateBodyRunnerLogLevel `json:"runner_log_level,omitempty"`
}

// DeploymentCreateBodyMode The mode of the deployment. Defaults to 'deploy'. Can be set to 'plan_only' to test and validate a deployment.
type DeploymentCreateBodyMode string

// DeploymentCreateBodyRunnerLogLevel The log level for the runner.
type DeploymentCreateBodyRunnerLogLevel string

// DeploymentDryRun defines model for DeploymentDryRun.
type DeploymentDryRun struct {
	// RunnerId The Runner ID that this deployment would have executed on
	RunnerId string `json:"runner_id"`
}

// DeploymentEncryptedOutputs defines model for DeploymentEncryptedOutputs.
type DeploymentEncryptedOutputs struct {
	// Raw The base64 encoded encrypted outputs. These are returned in standard base64 with padding. The outputs are encrypted with https://age-encryption.org/ and may
	// be decrypted by the holder of the recipients key.
	Raw string `json:"raw"`
}

// DeploymentId The unique deployment id
type DeploymentId = openapi_types.UUID

// DeploymentManifest The manifest associated with a deployment
type DeploymentManifest struct {
	// Shared The set of named shared resources.
	Shared map[string]DeploymentManifestResource `json:"shared,omitempty"`

	// Workloads The set of workloads in the environment.
	Workloads map[string]DeploymentManifestWorkload `json:"workloads"`
}

// DeploymentManifestResource A resource to provision as part of the deployment
type DeploymentManifestResource struct {
	// Class A resource class requested by the resource graph. 'default' is the default value.
	Class *ResourceClass `json:"class,omitempty"`

	// Id A specific resource id requested by the resource graph
	Id *ResourceId `json:"id,omitempty"`

	// Params Optional parameters to pass to the resource provisioning.
	Params map[string]interface{} `json:"params,omitempty"`

	// Type The resource type to provision
	Type string `json:"type"`
}

// DeploymentManifestWorkload defines model for DeploymentManifestWorkload.
type DeploymentManifestWorkload struct {
	Resources map[string]DeploymentManifestResource `json:"resources,omitempty"`
	Variables map[string]string                     `json:"variables,omitempty"`
}

// DeploymentMetrics Metrics resulting from a deployment.
type DeploymentMetrics struct {
	// NumResourceNodes The number of resource nodes in the graph.
	NumResourceNodes int `json:"num_resource_nodes"`

	// NumTfResources The number of terraformed resources. Only known after deployment.
	NumTfResources *int `json:"num_tf_resources,omitempty"`

	// NumTfResourcesAdded The number of terraformed resources added. Only known after deployment.
	NumTfResourcesAdded *int `json:"num_tf_resources_added,omitempty"`

	// NumTfResourcesChanged The number of terraformed resources changed. Only known after deployment.
	NumTfResourcesChanged *int `json:"num_tf_resources_changed,omitempty"`

	// NumTfResourcesRemoved The number of terraformed resources removed. Only known after deployment.
	NumTfResourcesRemoved *int `json:"num_tf_resources_removed,omitempty"`

	// NumWorkloads The number of workloads in the deployment.
	NumWorkloads int `json:"num_workloads"`
}

// DeploymentPage A page of deployments
type DeploymentPage struct {
	Items []DeploymentSummary `json:"items"`

	// NextPageToken The page token to use to request the next page of items
	NextPageToken *string `json:"next_page_token,omitempty"`
}

// DeploymentResultMetadata The metadata produced by the resources involved in the deployment.
type DeploymentResultMetadata = []DeploymentResultMetadataPerNode

// DeploymentResultMetadataPerNode The metadata produced by a specific resource identified by its hash.
type DeploymentResultMetadataPerNode struct {
	// Metadata The metadata output by the module which provisioned the resource.
	Metadata map[string]interface{} `json:"metadata"`

	// NodeId The hash of the active resource node.
	NodeId string `json:"node_id"`
}

// DeploymentResultsUpdateBody The outcome of the runner execution.
type DeploymentResultsUpdateBody struct {
	// Error A standard error response
	Error *Error `json:"error,omitempty"`

	// Metadata The metadata produced by the resources involved in the deployment.
	Metadata DeploymentResultMetadata `json:"metadata,omitempty"`

	// Outputs The encrypted outputs produced by the runner.
	Outputs *string `json:"outputs,omitempty"`

	// Status The overall status of the runner execution.
	Status DeploymentResultsUpdateBodyStatus `json:"status"`

	// TfResourceCounts Details about the Terraform resources added / removed / changed .
	TfResourceCounts DeploymentTFResourceCounts `json:"tf_resource_counts,omitempty"`
}

// DeploymentResultsUpdateBodyStatus The overall status of the runner execution.
type DeploymentResultsUpdateBodyStatus string

// DeploymentSummary Summary information for a deployment, more information can be retrieved through the GetDeployment APIs.
type DeploymentSummary struct {
	// CompletedAt The time the deployment succeeded, failed, or terminated
	CompletedAt *time.Time `json:"completed_at,omitempty"`

	// CreatedAt The time the deployment was created
	CreatedAt time.Time `json:"created_at"`

	// CreatedBy The user that created the deployment
	CreatedBy openapi_types.UUID `json:"created_by"`

	// EnvId The Environment id in the project which is being deployed
	EnvId string `json:"env_id"`

	// Id The unique deployment id
	Id DeploymentId `json:"id"`

	// Metrics Metrics resulting from a deployment.
	Metrics DeploymentMetrics `json:"metrics"`

	// Mode The mode of the deployment.
	Mode string `json:"mode"`

	// OrgId The Organization ID
	OrgId OrganizationId `json:"org_id"`

	// ProjectId The Project id which the environment exists in
	ProjectId string `json:"project_id"`

	// Status The status of the deployment.
	Status string `json:"status"`

	// StatusMessage A message associated with the 'status'.
	StatusMessage string `json:"status_message"`
}

// DeploymentTFResourceCounts Details about the Terraform resources added / removed / changed .
type DeploymentTFResourceCounts struct {
	// NumResources Number of Terraform resources involved in the deployment.
	NumResources int `json:"num_resources"`

	// NumResourcesAdded Number of Terraform resources added by this deployment run.
	NumResourcesAdded int `json:"num_resources_added"`

	// NumResourcesChanged Number of Terraform resources changed by this deployment run.
	NumResourcesChanged int `json:"num_resources_changed"`

	// NumResourcesRemoved Number of Terraform resources removed by this deployment run.
	NumResourcesRemoved int `json:"num_resources_removed"`
}

// Error A standard error response
type Error struct {
	// Details An optional payload of metadata associated with the error.
	Details *map[string]interface{} `json:"details,omitempty"`

	// Error A short code representing the class of error. This code can be used for tracking and observability or to
	// find appropriate troubleshooting documentation.
	Error string `json:"error"`

	// Message A human-readable explanation of the error.
	Message string `json:"message"`
}

// InternalModuleUsage defines model for InternalModuleUsage.
type InternalModuleUsage struct {
	EnvIdsByProjectId map[string][]string `json:"env_ids_by_project_id"`
}

// Jwk JSON Web Key
type Jwk struct {
	Alg string    `json:"alg"`
	E   string    `json:"e"`
	Kid string    `json:"kid"`
	Kty string    `json:"kty"`
	N   string    `json:"n"`
	Use string    `json:"use"`
	X5c *[]string `json:"x5c,omitempty"`
	X5t *string   `json:"x5t,omitempty"`
}

// Jwks JSON Web Keys Set (JWKS).
type Jwks struct {
	Keys []Jwk `json:"keys"`
}

// ListActiveResourceNodesPage defines model for ListActiveResourceNodesPage.
type ListActiveResourceNodesPage struct {
	// Items The list of active resource nodes.
	Items []ActiveResourceNode `json:"items"`
}

// MetadataKey A metadata key for an organization.
type MetadataKey struct {
	// CreatedAt The time the metadata key was created
	CreatedAt time.Time `json:"created_at"`

	// Description A human-readable description of the metadata key.
	Description *string `json:"description,omitempty"`

	// Name The name of the metadata key.
	Name string `json:"name"`

	// Schema The schema of the metadata key.
	Schema MetadataKeySchema `json:"schema"`
}

// MetadataKeyCreateBody A metadata key for an organization.
type MetadataKeyCreateBody struct {
	// Description A human-readable description of the metadata key.
	Description *string `json:"description,omitempty"`

	// Name The name of the metadata key.
	Name string `json:"name"`

	// Schema The schema of the metadata key.
	Schema MetadataKeySchema `json:"schema"`
}

// MetadataKeyPage A page of metadata keys
type MetadataKeyPage struct {
	Items []MetadataKey `json:"items"`

	// NextPageToken The page token to use to request the next page of items
	NextPageToken *string `json:"next_page_token,omitempty"`
}

// MetadataKeySchema The schema of the metadata key.
type MetadataKeySchema struct {
	// Format The format of the metadata key.
	Format *string `json:"format,omitempty"`

	// Pattern A regular expression pattern for the metadata key.
	Pattern *string `json:"pattern,omitempty"`

	// Type The type of the metadata key.
	Type MetadataKeySchemaType `json:"type"`
}

// MetadataKeySchemaType The type of the metadata key.
type MetadataKeySchemaType string

// MetadataKeyUpdateBody A metadata key for an organization.
type MetadataKeyUpdateBody struct {
	// Description A human-readable description of the metadata key.
	Description *string `json:"description,omitempty"`

	// Schema The schema of the metadata key.
	Schema *UpdateMetadataKeySchema `json:"schema,omitempty"`
}

// OpenidConfiguration OpenID discovery configuration.
type OpenidConfiguration struct {
	ClaimsSupported                  []string `json:"claims_supported"`
	IdTokenSigningAlgValuesSupported []string `json:"id_token_signing_alg_values_supported"`
	Issuer                           string   `json:"issuer"`
	JwksUri                          string   `json:"jwks_uri"`
	ResponseTypesSupported           []string `json:"response_types_supported"`
	ScopesSupported                  []string `json:"scopes_supported"`
	SubjectTypesSupported            []string `json:"subject_types_supported"`
}

// OrganizationId The Organization ID
type OrganizationId = string

// RemoteRunnerMessage defines model for RemoteRunnerMessage.
type RemoteRunnerMessage struct {
	union json.RawMessage
}

// RemoteRunnerMessageAction The action to be performed by the remote runner.
type RemoteRunnerMessageAction string

// RemoteRunnerMessageCheckJobStatus The response for checking the status of a job on the runner.
type RemoteRunnerMessageCheckJobStatus struct {
	// Action The action to be performed by the remote runner.
	Action RemoteRunnerMessageAction `json:"action"`

	// DeploymentToken The deployment token to authenticate any request to update deployment results from the remote runner.
	DeploymentToken string `json:"deployment_token"`

	// ExpiresAt The time at which the job should be considered stuck by the runner if no pods are running or completed.
	ExpiresAt time.Time `json:"expires_at"`

	// JobId The ID of the job whose status is being requested.
	JobId string `json:"job_id"`

	// Namespace The ID of the namespace associated with the job.
	Namespace string `json:"namespace"`
}

// RemoteRunnerMessageCreateJob The response for creating a job on the runner.
type RemoteRunnerMessageCreateJob struct {
	// Action The action to be performed by the remote runner.
	Action RemoteRunnerMessageAction `json:"action"`

	// Configuration The configuration for the job to be created on the runner. It must be parsable into a kubernetes Job definition.
	Configuration map[string]interface{} `json:"configuration"`

	// DeploymentToken The deployment token to authenticate any request to update deployment results from the remote runner.
	DeploymentToken string `json:"deployment_token"`

	// JobId The ID of the job created on the runner.
	JobId string `json:"job_id"`

	// Namespace The ID of the namespace associated with the job.
	Namespace string `json:"namespace"`
}

// ResourceClass A resource class requested by the resource graph. 'default' is the default value.
type ResourceClass = string

// ResourceId A specific resource id requested by the resource graph
type ResourceId = string

// UpdateMetadataKeySchema The schema of the metadata key.
type UpdateMetadataKeySchema struct {
	// Format The format of the metadata key.
	Format *string `json:"format,omitempty"`

	// Pattern A regular expression pattern for the metadata key.
	Pattern *string `json:"pattern,omitempty"`

	// Type The type of the metadata key.
	Type *UpdateMetadataKeySchemaType `json:"type,omitempty"`
}

// UpdateMetadataKeySchemaType The type of the metadata key.
type UpdateMetadataKeySchemaType string

// DeploymentIdPathParam defines model for deploymentIdPathParam.
type DeploymentIdPathParam = openapi_types.UUID

// EnvIdQueryParam defines model for envIdQueryParam.
type EnvIdQueryParam = string

// MetadataKeyNamePathParam defines model for metadataKeyNamePathParam.
type MetadataKeyNamePathParam = string

// OrgIdPathParam defines model for orgIdPathParam.
type OrgIdPathParam = string

// PageTokenQueryParam defines model for pageTokenQueryParam.
type PageTokenQueryParam = string

// PerPageQueryParam defines model for perPageQueryParam.
type PerPageQueryParam = int

// ProjectIdQueryParam defines model for projectIdQueryParam.
type ProjectIdQueryParam = string

// RunnerIdPathParam defines model for runnerIdPathParam.
type RunnerIdPathParam = string

// N400BadRequest A standard error response
type N400BadRequest = Error

// N404NotFound A standard error response
type N404NotFound = Error

// N409Conflict A standard error response
type N409Conflict = Error

// InternalDeleteDeploymentsParams defines parameters for InternalDeleteDeployments.
type InternalDeleteDeploymentsParams struct {
	// ProjectId The Project ID
	ProjectId *ProjectIdQueryParam `form:"project_id,omitempty" json:"project_id,omitempty"`

	// EnvId The Environment ID
	EnvId *EnvIdQueryParam `form:"env_id,omitempty" json:"env_id,omitempty"`

	// Force Whether to ignore the requirement for the last deployment to be a successful destroy. This should only be used in exceptional circumstances.
	Force *bool `form:"force,omitempty" json:"force,omitempty"`
}

// InternalCheckModuleUsageParams defines parameters for InternalCheckModuleUsage.
type InternalCheckModuleUsageParams struct {
	ModuleVersion *string `form:"module_version,omitempty" json:"module_version,omitempty"`
}

// ListActiveResourceNodesParams defines parameters for ListActiveResourceNodes.
type ListActiveResourceNodesParams struct {
	// ProjectId The Project ID
	ProjectId *ProjectIdQueryParam `form:"project_id,omitempty" json:"project_id,omitempty"`

	// EnvId The Environment ID
	EnvId *EnvIdQueryParam `form:"env_id,omitempty" json:"env_id,omitempty"`
}

// ListDeploymentsParams defines parameters for ListDeployments.
type ListDeploymentsParams struct {
	// ProjectId The Project ID
	ProjectId *ProjectIdQueryParam `form:"project_id,omitempty" json:"project_id,omitempty"`

	// EnvId The Environment ID
	EnvId *EnvIdQueryParam `form:"env_id,omitempty" json:"env_id,omitempty"`

	// PerPage The maximum number of items to return in a page of results
	PerPage *PerPageQueryParam `form:"per_page,omitempty" json:"per_page,omitempty"`

	// Page The page token to request from
	Page *PageTokenQueryParam `form:"page,omitempty" json:"page,omitempty"`
}

// CreateDeploymentParams defines parameters for CreateDeployment.
type CreateDeploymentParams struct {
	// IdempotencyKey Ensures that the deployment request is only accepted once per idempotency key per 24 hours. A uuid or similar is recommended.
	// When the key matches the key in last deployment and the environment and manifest is the same, this will return the last deployment.
	IdempotencyKey *string `json:"Idempotency-Key,omitempty"`
}

// GetDeploymentLogsParams defines parameters for GetDeploymentLogs.
type GetDeploymentLogsParams struct {
	// DecryptKey The private key needed to decrypt the logs. It should be an 'age' private key (see https://age-encryption.org).
	DecryptKey *string `json:"DecryptKey,omitempty"`
}

// WaitForDeploymentCompleteParams defines parameters for WaitForDeploymentComplete.
type WaitForDeploymentCompleteParams struct {
	// TimeoutInSeconds Sets a maximum timeout before the HTTP-408 response is returned.
	TimeoutInSeconds *int `form:"timeout_in_seconds,omitempty" json:"timeout_in_seconds,omitempty"`
}

// GetDeploymentBundleParams defines parameters for GetDeploymentBundle.
type GetDeploymentBundleParams struct {
	XDeploymentToken string `json:"X-Deployment-Token"`
}

// UpdateDeploymentResultsParams defines parameters for UpdateDeploymentResults.
type UpdateDeploymentResultsParams struct {
	XDeploymentToken string `json:"X-Deployment-Token"`
}

// ListLastDeploymentsParams defines parameters for ListLastDeployments.
type ListLastDeploymentsParams struct {
	// ProjectId The Project ID
	ProjectId *ProjectIdQueryParam `form:"project_id,omitempty" json:"project_id,omitempty"`

	// EnvId The Environment ID
	EnvId *EnvIdQueryParam `form:"env_id,omitempty" json:"env_id,omitempty"`

	// PerPage The maximum number of items to return in a page of results
	PerPage *PerPageQueryParam `form:"per_page,omitempty" json:"per_page,omitempty"`

	// Page The page token to request from
	Page *PageTokenQueryParam `form:"page,omitempty" json:"page,omitempty"`

	// StateChangeOnly Whether to return the last state change (apply or destroy) deployment for the target environment.
	StateChangeOnly *bool `form:"state_change_only,omitempty" json:"state_change_only,omitempty"`
}

// ListMetadataKeysParams defines parameters for ListMetadataKeys.
type ListMetadataKeysParams struct {
	// PerPage The maximum number of items to return in a page of results
	PerPage *PerPageQueryParam `form:"per_page,omitempty" json:"per_page,omitempty"`

	// Page The page token to request from
	Page *PageTokenQueryParam `form:"page,omitempty" json:"page,omitempty"`
}

// InternalPushMessageToRemoteRunnerJSONRequestBody defines body for InternalPushMessageToRemoteRunner for application/json ContentType.
type InternalPushMessageToRemoteRunnerJSONRequestBody = RemoteRunnerMessage

// CreateDeploymentJSONRequestBody defines body for CreateDeployment for application/json ContentType.
type CreateDeploymentJSONRequestBody = DeploymentCreateBody

// UpdateDeploymentResultsJSONRequestBody defines body for UpdateDeploymentResults for application/json ContentType.
type UpdateDeploymentResultsJSONRequestBody = DeploymentResultsUpdateBody

// CreateMetadataKeyJSONRequestBody defines body for CreateMetadataKey for application/json ContentType.
type CreateMetadataKeyJSONRequestBody = MetadataKeyCreateBody

// UpdateMetadataKeyJSONRequestBody defines body for UpdateMetadataKey for application/json ContentType.
type UpdateMetadataKeyJSONRequestBody = MetadataKeyUpdateBody

// AsRemoteRunnerMessageCreateJob returns the union data inside the RemoteRunnerMessage as a RemoteRunnerMessageCreateJob
func (t RemoteRunnerMessage) AsRemoteRunnerMessageCreateJob() (RemoteRunnerMessageCreateJob, error) {
	var body RemoteRunnerMessageCreateJob
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromRemoteRunnerMessageCreateJob overwrites any union data inside the RemoteRunnerMessage as the provided RemoteRunnerMessageCreateJob
func (t *RemoteRunnerMessage) FromRemoteRunnerMessageCreateJob(v RemoteRunnerMessageCreateJob) error {
	v.Action = "create-job"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeRemoteRunnerMessageCreateJob performs a merge with any union data inside the RemoteRunnerMessage, using the provided RemoteRunnerMessageCreateJob
func (t *RemoteRunnerMessage) MergeRemoteRunnerMessageCreateJob(v RemoteRunnerMessageCreateJob) error {
	v.Action = "create-job"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsRemoteRunnerMessageCheckJobStatus returns the union data inside the RemoteRunnerMessage as a RemoteRunnerMessageCheckJobStatus
func (t RemoteRunnerMessage) AsRemoteRunnerMessageCheckJobStatus() (RemoteRunnerMessageCheckJobStatus, error) {
	var body RemoteRunnerMessageCheckJobStatus
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromRemoteRunnerMessageCheckJobStatus overwrites any union data inside the RemoteRunnerMessage as the provided RemoteRunnerMessageCheckJobStatus
func (t *RemoteRunnerMessage) FromRemoteRunnerMessageCheckJobStatus(v RemoteRunnerMessageCheckJobStatus) error {
	v.Action = "check-job-status"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeRemoteRunnerMessageCheckJobStatus performs a merge with any union data inside the RemoteRunnerMessage, using the provided RemoteRunnerMessageCheckJobStatus
func (t *RemoteRunnerMessage) MergeRemoteRunnerMessageCheckJobStatus(v RemoteRunnerMessageCheckJobStatus) error {
	v.Action = "check-job-status"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t RemoteRunnerMessage) Discriminator() (string, error) {
	var discriminator struct {
		Discriminator string `json:"action"`
	}
	err := json.Unmarshal(t.union, &discriminator)
	return discriminator.Discriminator, err
}

func (t RemoteRunnerMessage) ValueByDiscriminator() (interface{}, error) {
	discriminator, err := t.Discriminator()
	if err != nil {
		return nil, err
	}
	switch discriminator {
	case "check-job-status":
		return t.AsRemoteRunnerMessageCheckJobStatus()
	case "create-job":
		return t.AsRemoteRunnerMessageCreateJob()
	default:
		return nil, errors.New("unknown discriminator value: " + discriminator)
	}
}

func (t RemoteRunnerMessage) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *RemoteRunnerMessage) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// RequestEditorFn  is the function signature for the RequestEditor callback function
type RequestEditorFn func(ctx context.Context, req *http.Request) error

// Doer performs HTTP requests.
//
// The standard http.Client implements this interface.
type HttpRequestDoer interface {
	Do(req *http.Request) (*http.Response, error)
}

// Client which conforms to the OpenAPI3 specification for this service.
type Client struct {
	// The endpoint of the server conforming to this interface, with scheme,
	// https://api.deepmap.com for example. This can contain a path relative
	// to the server, such as https://api.deepmap.com/dev-test, and all the
	// paths in the swagger spec will be appended to the server.
	Server string

	// Doer for performing requests, typically a *http.Client with any
	// customized settings, such as certificate chains.
	Client HttpRequestDoer

	// A list of callbacks for modifying requests which are generated before sending over
	// the network.
	RequestEditors []RequestEditorFn
}

// ClientOption allows setting custom parameters during construction
type ClientOption func(*Client) error

// Creates a new Client, with reasonable defaults
func NewClient(server string, opts ...ClientOption) (*Client, error) {
	// create a client with sane default values
	client := Client{
		Server: server,
	}
	// mutate client and add all optional params
	for _, o := range opts {
		if err := o(&client); err != nil {
			return nil, err
		}
	}
	// ensure the server URL always has a trailing slash
	if !strings.HasSuffix(client.Server, "/") {
		client.Server += "/"
	}
	// create httpClient, if not already present
	if client.Client == nil {
		client.Client = &http.Client{}
	}
	return &client, nil
}

// WithHTTPClient allows overriding the default Doer, which is
// automatically created using http.Client. This is useful for tests.
func WithHTTPClient(doer HttpRequestDoer) ClientOption {
	return func(c *Client) error {
		c.Client = doer
		return nil
	}
}

// WithRequestEditorFn allows setting up a callback function, which will be
// called right before sending the request. This can be used to mutate the request.
func WithRequestEditorFn(fn RequestEditorFn) ClientOption {
	return func(c *Client) error {
		c.RequestEditors = append(c.RequestEditors, fn)
		return nil
	}
}

// The interface specification for the client above.
type ClientInterface interface {
	// GetJwks request
	GetJwks(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetOpenidConfiguration request
	GetOpenidConfiguration(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// InternalDeleteDeployments request
	InternalDeleteDeployments(ctx context.Context, orgId OrgIdPathParam, params *InternalDeleteDeploymentsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// InternalForceFailDeployment request
	InternalForceFailDeployment(ctx context.Context, orgId OrgIdPathParam, deploymentId DeploymentIdPathParam, reqEditors ...RequestEditorFn) (*http.Response, error)

	// InternalCheckModuleUsage request
	InternalCheckModuleUsage(ctx context.Context, orgId OrgIdPathParam, moduleId string, params *InternalCheckModuleUsageParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// InternalPushMessageToRemoteRunnerWithBody request with any body
	InternalPushMessageToRemoteRunnerWithBody(ctx context.Context, orgId OrgIdPathParam, runnerId RunnerIdPathParam, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	InternalPushMessageToRemoteRunner(ctx context.Context, orgId OrgIdPathParam, runnerId RunnerIdPathParam, body InternalPushMessageToRemoteRunnerJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListActiveResourceNodes request
	ListActiveResourceNodes(ctx context.Context, orgId OrgIdPathParam, params *ListActiveResourceNodesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListDeployments request
	ListDeployments(ctx context.Context, orgId OrgIdPathParam, params *ListDeploymentsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateDeploymentWithBody request with any body
	CreateDeploymentWithBody(ctx context.Context, orgId OrgIdPathParam, params *CreateDeploymentParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateDeployment(ctx context.Context, orgId OrgIdPathParam, params *CreateDeploymentParams, body CreateDeploymentJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetDeployment request
	GetDeployment(ctx context.Context, orgId OrgIdPathParam, deploymentId DeploymentIdPathParam, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetDeploymentLogs request
	GetDeploymentLogs(ctx context.Context, orgId OrgIdPathParam, deploymentId DeploymentIdPathParam, params *GetDeploymentLogsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// WaitForDeploymentComplete request
	WaitForDeploymentComplete(ctx context.Context, orgId OrgIdPathParam, deploymentId DeploymentIdPathParam, params *WaitForDeploymentCompleteParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetDeploymentBundle request
	GetDeploymentBundle(ctx context.Context, orgId OrgIdPathParam, deploymentId DeploymentIdPathParam, params *GetDeploymentBundleParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetDeploymentEncryptedOutputs request
	GetDeploymentEncryptedOutputs(ctx context.Context, orgId OrgIdPathParam, deploymentId DeploymentIdPathParam, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateDeploymentResultsWithBody request with any body
	UpdateDeploymentResultsWithBody(ctx context.Context, orgId OrgIdPathParam, deploymentId DeploymentIdPathParam, params *UpdateDeploymentResultsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateDeploymentResults(ctx context.Context, orgId OrgIdPathParam, deploymentId DeploymentIdPathParam, params *UpdateDeploymentResultsParams, body UpdateDeploymentResultsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetDeploymentTf request
	GetDeploymentTf(ctx context.Context, orgId OrgIdPathParam, deploymentId DeploymentIdPathParam, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListLastDeployments request
	ListLastDeployments(ctx context.Context, orgId OrgIdPathParam, params *ListLastDeploymentsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListMetadataKeys request
	ListMetadataKeys(ctx context.Context, orgId OrgIdPathParam, params *ListMetadataKeysParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateMetadataKeyWithBody request with any body
	CreateMetadataKeyWithBody(ctx context.Context, orgId OrgIdPathParam, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateMetadataKey(ctx context.Context, orgId OrgIdPathParam, body CreateMetadataKeyJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteMetadataKey request
	DeleteMetadataKey(ctx context.Context, orgId OrgIdPathParam, metadataKeyName MetadataKeyNamePathParam, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetMetadataKey request
	GetMetadataKey(ctx context.Context, orgId OrgIdPathParam, metadataKeyName MetadataKeyNamePathParam, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateMetadataKeyWithBody request with any body
	UpdateMetadataKeyWithBody(ctx context.Context, orgId OrgIdPathParam, metadataKeyName MetadataKeyNamePathParam, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateMetadataKey(ctx context.Context, orgId OrgIdPathParam, metadataKeyName MetadataKeyNamePathParam, body UpdateMetadataKeyJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// WaitForRemoteRunnerMessages request
	WaitForRemoteRunnerMessages(ctx context.Context, orgId OrgIdPathParam, runnerId RunnerIdPathParam, reqEditors ...RequestEditorFn) (*http.Response, error)
}

func (c *Client) GetJwks(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetJwksRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetOpenidConfiguration(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetOpenidConfigurationRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) InternalDeleteDeployments(ctx context.Context, orgId OrgIdPathParam, params *InternalDeleteDeploymentsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewInternalDeleteDeploymentsRequest(c.Server, orgId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) InternalForceFailDeployment(ctx context.Context, orgId OrgIdPathParam, deploymentId DeploymentIdPathParam, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewInternalForceFailDeploymentRequest(c.Server, orgId, deploymentId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) InternalCheckModuleUsage(ctx context.Context, orgId OrgIdPathParam, moduleId string, params *InternalCheckModuleUsageParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewInternalCheckModuleUsageRequest(c.Server, orgId, moduleId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) InternalPushMessageToRemoteRunnerWithBody(ctx context.Context, orgId OrgIdPathParam, runnerId RunnerIdPathParam, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewInternalPushMessageToRemoteRunnerRequestWithBody(c.Server, orgId, runnerId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) InternalPushMessageToRemoteRunner(ctx context.Context, orgId OrgIdPathParam, runnerId RunnerIdPathParam, body InternalPushMessageToRemoteRunnerJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewInternalPushMessageToRemoteRunnerRequest(c.Server, orgId, runnerId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListActiveResourceNodes(ctx context.Context, orgId OrgIdPathParam, params *ListActiveResourceNodesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListActiveResourceNodesRequest(c.Server, orgId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListDeployments(ctx context.Context, orgId OrgIdPathParam, params *ListDeploymentsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListDeploymentsRequest(c.Server, orgId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateDeploymentWithBody(ctx context.Context, orgId OrgIdPathParam, params *CreateDeploymentParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateDeploymentRequestWithBody(c.Server, orgId, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateDeployment(ctx context.Context, orgId OrgIdPathParam, params *CreateDeploymentParams, body CreateDeploymentJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateDeploymentRequest(c.Server, orgId, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetDeployment(ctx context.Context, orgId OrgIdPathParam, deploymentId DeploymentIdPathParam, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetDeploymentRequest(c.Server, orgId, deploymentId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetDeploymentLogs(ctx context.Context, orgId OrgIdPathParam, deploymentId DeploymentIdPathParam, params *GetDeploymentLogsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetDeploymentLogsRequest(c.Server, orgId, deploymentId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) WaitForDeploymentComplete(ctx context.Context, orgId OrgIdPathParam, deploymentId DeploymentIdPathParam, params *WaitForDeploymentCompleteParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewWaitForDeploymentCompleteRequest(c.Server, orgId, deploymentId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetDeploymentBundle(ctx context.Context, orgId OrgIdPathParam, deploymentId DeploymentIdPathParam, params *GetDeploymentBundleParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetDeploymentBundleRequest(c.Server, orgId, deploymentId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetDeploymentEncryptedOutputs(ctx context.Context, orgId OrgIdPathParam, deploymentId DeploymentIdPathParam, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetDeploymentEncryptedOutputsRequest(c.Server, orgId, deploymentId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateDeploymentResultsWithBody(ctx context.Context, orgId OrgIdPathParam, deploymentId DeploymentIdPathParam, params *UpdateDeploymentResultsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateDeploymentResultsRequestWithBody(c.Server, orgId, deploymentId, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateDeploymentResults(ctx context.Context, orgId OrgIdPathParam, deploymentId DeploymentIdPathParam, params *UpdateDeploymentResultsParams, body UpdateDeploymentResultsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateDeploymentResultsRequest(c.Server, orgId, deploymentId, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetDeploymentTf(ctx context.Context, orgId OrgIdPathParam, deploymentId DeploymentIdPathParam, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetDeploymentTfRequest(c.Server, orgId, deploymentId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListLastDeployments(ctx context.Context, orgId OrgIdPathParam, params *ListLastDeploymentsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListLastDeploymentsRequest(c.Server, orgId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListMetadataKeys(ctx context.Context, orgId OrgIdPathParam, params *ListMetadataKeysParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListMetadataKeysRequest(c.Server, orgId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateMetadataKeyWithBody(ctx context.Context, orgId OrgIdPathParam, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateMetadataKeyRequestWithBody(c.Server, orgId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateMetadataKey(ctx context.Context, orgId OrgIdPathParam, body CreateMetadataKeyJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateMetadataKeyRequest(c.Server, orgId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteMetadataKey(ctx context.Context, orgId OrgIdPathParam, metadataKeyName MetadataKeyNamePathParam, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteMetadataKeyRequest(c.Server, orgId, metadataKeyName)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetMetadataKey(ctx context.Context, orgId OrgIdPathParam, metadataKeyName MetadataKeyNamePathParam, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetMetadataKeyRequest(c.Server, orgId, metadataKeyName)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateMetadataKeyWithBody(ctx context.Context, orgId OrgIdPathParam, metadataKeyName MetadataKeyNamePathParam, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateMetadataKeyRequestWithBody(c.Server, orgId, metadataKeyName, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateMetadataKey(ctx context.Context, orgId OrgIdPathParam, metadataKeyName MetadataKeyNamePathParam, body UpdateMetadataKeyJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateMetadataKeyRequest(c.Server, orgId, metadataKeyName, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) WaitForRemoteRunnerMessages(ctx context.Context, orgId OrgIdPathParam, runnerId RunnerIdPathParam, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewWaitForRemoteRunnerMessagesRequest(c.Server, orgId, runnerId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

// NewGetJwksRequest generates requests for GetJwks
func NewGetJwksRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/.well-known/jwks")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetOpenidConfigurationRequest generates requests for GetOpenidConfiguration
func NewGetOpenidConfigurationRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/.well-known/openid-configuration")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewInternalDeleteDeploymentsRequest generates requests for InternalDeleteDeployments
func NewInternalDeleteDeploymentsRequest(server string, orgId OrgIdPathParam, params *InternalDeleteDeploymentsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "orgId", runtime.ParamLocationPath, orgId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/internal/orgs/%s/deployments", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.ProjectId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "project_id", runtime.ParamLocationQuery, *params.ProjectId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.EnvId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "env_id", runtime.ParamLocationQuery, *params.EnvId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Force != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force", runtime.ParamLocationQuery, *params.Force); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewInternalForceFailDeploymentRequest generates requests for InternalForceFailDeployment
func NewInternalForceFailDeploymentRequest(server string, orgId OrgIdPathParam, deploymentId DeploymentIdPathParam) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "orgId", runtime.ParamLocationPath, orgId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "deploymentId", runtime.ParamLocationPath, deploymentId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/internal/orgs/%s/deployments/%s/actions/force-failure", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewInternalCheckModuleUsageRequest generates requests for InternalCheckModuleUsage
func NewInternalCheckModuleUsageRequest(server string, orgId OrgIdPathParam, moduleId string, params *InternalCheckModuleUsageParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "orgId", runtime.ParamLocationPath, orgId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "moduleId", runtime.ParamLocationPath, moduleId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/internal/orgs/%s/modules/%s/actions/check-usage", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.ModuleVersion != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "module_version", runtime.ParamLocationQuery, *params.ModuleVersion); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewInternalPushMessageToRemoteRunnerRequest calls the generic InternalPushMessageToRemoteRunner builder with application/json body
func NewInternalPushMessageToRemoteRunnerRequest(server string, orgId OrgIdPathParam, runnerId RunnerIdPathParam, body InternalPushMessageToRemoteRunnerJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewInternalPushMessageToRemoteRunnerRequestWithBody(server, orgId, runnerId, "application/json", bodyReader)
}

// NewInternalPushMessageToRemoteRunnerRequestWithBody generates requests for InternalPushMessageToRemoteRunner with any type of body
func NewInternalPushMessageToRemoteRunnerRequestWithBody(server string, orgId OrgIdPathParam, runnerId RunnerIdPathParam, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "orgId", runtime.ParamLocationPath, orgId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "runnerId", runtime.ParamLocationPath, runnerId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/internal/orgs/%s/remote-runners/%s/actions/push-message", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewListActiveResourceNodesRequest generates requests for ListActiveResourceNodes
func NewListActiveResourceNodesRequest(server string, orgId OrgIdPathParam, params *ListActiveResourceNodesParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "orgId", runtime.ParamLocationPath, orgId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/orgs/%s/active-resources", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.ProjectId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "project_id", runtime.ParamLocationQuery, *params.ProjectId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.EnvId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "env_id", runtime.ParamLocationQuery, *params.EnvId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListDeploymentsRequest generates requests for ListDeployments
func NewListDeploymentsRequest(server string, orgId OrgIdPathParam, params *ListDeploymentsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "orgId", runtime.ParamLocationPath, orgId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/orgs/%s/deployments", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.ProjectId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "project_id", runtime.ParamLocationQuery, *params.ProjectId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.EnvId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "env_id", runtime.ParamLocationQuery, *params.EnvId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PerPage != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "per_page", runtime.ParamLocationQuery, *params.PerPage); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Page != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateDeploymentRequest calls the generic CreateDeployment builder with application/json body
func NewCreateDeploymentRequest(server string, orgId OrgIdPathParam, params *CreateDeploymentParams, body CreateDeploymentJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateDeploymentRequestWithBody(server, orgId, params, "application/json", bodyReader)
}

// NewCreateDeploymentRequestWithBody generates requests for CreateDeployment with any type of body
func NewCreateDeploymentRequestWithBody(server string, orgId OrgIdPathParam, params *CreateDeploymentParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "orgId", runtime.ParamLocationPath, orgId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/orgs/%s/deployments", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		if params.IdempotencyKey != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Idempotency-Key", runtime.ParamLocationHeader, *params.IdempotencyKey)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Idempotency-Key", headerParam0)
		}

	}

	return req, nil
}

// NewGetDeploymentRequest generates requests for GetDeployment
func NewGetDeploymentRequest(server string, orgId OrgIdPathParam, deploymentId DeploymentIdPathParam) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "orgId", runtime.ParamLocationPath, orgId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "deploymentId", runtime.ParamLocationPath, deploymentId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/orgs/%s/deployments/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetDeploymentLogsRequest generates requests for GetDeploymentLogs
func NewGetDeploymentLogsRequest(server string, orgId OrgIdPathParam, deploymentId DeploymentIdPathParam, params *GetDeploymentLogsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "orgId", runtime.ParamLocationPath, orgId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "deploymentId", runtime.ParamLocationPath, deploymentId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/orgs/%s/deployments/%s/actions/get-logs", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.DecryptKey != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "DecryptKey", runtime.ParamLocationHeader, *params.DecryptKey)
			if err != nil {
				return nil, err
			}

			req.Header.Set("DecryptKey", headerParam0)
		}

	}

	return req, nil
}

// NewWaitForDeploymentCompleteRequest generates requests for WaitForDeploymentComplete
func NewWaitForDeploymentCompleteRequest(server string, orgId OrgIdPathParam, deploymentId DeploymentIdPathParam, params *WaitForDeploymentCompleteParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "orgId", runtime.ParamLocationPath, orgId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "deploymentId", runtime.ParamLocationPath, deploymentId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/orgs/%s/deployments/%s/actions/wait-for-complete", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TimeoutInSeconds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "timeout_in_seconds", runtime.ParamLocationQuery, *params.TimeoutInSeconds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetDeploymentBundleRequest generates requests for GetDeploymentBundle
func NewGetDeploymentBundleRequest(server string, orgId OrgIdPathParam, deploymentId DeploymentIdPathParam, params *GetDeploymentBundleParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "orgId", runtime.ParamLocationPath, orgId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "deploymentId", runtime.ParamLocationPath, deploymentId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/orgs/%s/deployments/%s/bundle", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Deployment-Token", runtime.ParamLocationHeader, params.XDeploymentToken)
		if err != nil {
			return nil, err
		}

		req.Header.Set("X-Deployment-Token", headerParam0)

	}

	return req, nil
}

// NewGetDeploymentEncryptedOutputsRequest generates requests for GetDeploymentEncryptedOutputs
func NewGetDeploymentEncryptedOutputsRequest(server string, orgId OrgIdPathParam, deploymentId DeploymentIdPathParam) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "orgId", runtime.ParamLocationPath, orgId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "deploymentId", runtime.ParamLocationPath, deploymentId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/orgs/%s/deployments/%s/encrypted-outputs", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateDeploymentResultsRequest calls the generic UpdateDeploymentResults builder with application/json body
func NewUpdateDeploymentResultsRequest(server string, orgId OrgIdPathParam, deploymentId DeploymentIdPathParam, params *UpdateDeploymentResultsParams, body UpdateDeploymentResultsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateDeploymentResultsRequestWithBody(server, orgId, deploymentId, params, "application/json", bodyReader)
}

// NewUpdateDeploymentResultsRequestWithBody generates requests for UpdateDeploymentResults with any type of body
func NewUpdateDeploymentResultsRequestWithBody(server string, orgId OrgIdPathParam, deploymentId DeploymentIdPathParam, params *UpdateDeploymentResultsParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "orgId", runtime.ParamLocationPath, orgId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "deploymentId", runtime.ParamLocationPath, deploymentId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/orgs/%s/deployments/%s/results", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Deployment-Token", runtime.ParamLocationHeader, params.XDeploymentToken)
		if err != nil {
			return nil, err
		}

		req.Header.Set("X-Deployment-Token", headerParam0)

	}

	return req, nil
}

// NewGetDeploymentTfRequest generates requests for GetDeploymentTf
func NewGetDeploymentTfRequest(server string, orgId OrgIdPathParam, deploymentId DeploymentIdPathParam) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "orgId", runtime.ParamLocationPath, orgId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "deploymentId", runtime.ParamLocationPath, deploymentId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/orgs/%s/deployments/%s/tf", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListLastDeploymentsRequest generates requests for ListLastDeployments
func NewListLastDeploymentsRequest(server string, orgId OrgIdPathParam, params *ListLastDeploymentsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "orgId", runtime.ParamLocationPath, orgId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/orgs/%s/last-deployments", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.ProjectId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "project_id", runtime.ParamLocationQuery, *params.ProjectId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.EnvId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "env_id", runtime.ParamLocationQuery, *params.EnvId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PerPage != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "per_page", runtime.ParamLocationQuery, *params.PerPage); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Page != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.StateChangeOnly != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "state_change_only", runtime.ParamLocationQuery, *params.StateChangeOnly); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListMetadataKeysRequest generates requests for ListMetadataKeys
func NewListMetadataKeysRequest(server string, orgId OrgIdPathParam, params *ListMetadataKeysParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "orgId", runtime.ParamLocationPath, orgId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/orgs/%s/metadata-keys", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.PerPage != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "per_page", runtime.ParamLocationQuery, *params.PerPage); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Page != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateMetadataKeyRequest calls the generic CreateMetadataKey builder with application/json body
func NewCreateMetadataKeyRequest(server string, orgId OrgIdPathParam, body CreateMetadataKeyJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateMetadataKeyRequestWithBody(server, orgId, "application/json", bodyReader)
}

// NewCreateMetadataKeyRequestWithBody generates requests for CreateMetadataKey with any type of body
func NewCreateMetadataKeyRequestWithBody(server string, orgId OrgIdPathParam, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "orgId", runtime.ParamLocationPath, orgId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/orgs/%s/metadata-keys", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteMetadataKeyRequest generates requests for DeleteMetadataKey
func NewDeleteMetadataKeyRequest(server string, orgId OrgIdPathParam, metadataKeyName MetadataKeyNamePathParam) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "orgId", runtime.ParamLocationPath, orgId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "metadataKeyName", runtime.ParamLocationPath, metadataKeyName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/orgs/%s/metadata-keys/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetMetadataKeyRequest generates requests for GetMetadataKey
func NewGetMetadataKeyRequest(server string, orgId OrgIdPathParam, metadataKeyName MetadataKeyNamePathParam) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "orgId", runtime.ParamLocationPath, orgId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "metadataKeyName", runtime.ParamLocationPath, metadataKeyName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/orgs/%s/metadata-keys/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateMetadataKeyRequest calls the generic UpdateMetadataKey builder with application/json body
func NewUpdateMetadataKeyRequest(server string, orgId OrgIdPathParam, metadataKeyName MetadataKeyNamePathParam, body UpdateMetadataKeyJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateMetadataKeyRequestWithBody(server, orgId, metadataKeyName, "application/json", bodyReader)
}

// NewUpdateMetadataKeyRequestWithBody generates requests for UpdateMetadataKey with any type of body
func NewUpdateMetadataKeyRequestWithBody(server string, orgId OrgIdPathParam, metadataKeyName MetadataKeyNamePathParam, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "orgId", runtime.ParamLocationPath, orgId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "metadataKeyName", runtime.ParamLocationPath, metadataKeyName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/orgs/%s/metadata-keys/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewWaitForRemoteRunnerMessagesRequest generates requests for WaitForRemoteRunnerMessages
func NewWaitForRemoteRunnerMessagesRequest(server string, orgId OrgIdPathParam, runnerId RunnerIdPathParam) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "orgId", runtime.ParamLocationPath, orgId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "runnerId", runtime.ParamLocationPath, runnerId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/orgs/%s/remote-runners/%s/actions/poll-requests", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

func (c *Client) applyEditors(ctx context.Context, req *http.Request, additionalEditors []RequestEditorFn) error {
	for _, r := range c.RequestEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	for _, r := range additionalEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	return nil
}

// ClientWithResponses builds on ClientInterface to offer response payloads
type ClientWithResponses struct {
	ClientInterface
}

// NewClientWithResponses creates a new ClientWithResponses, which wraps
// Client with return type handling
func NewClientWithResponses(server string, opts ...ClientOption) (*ClientWithResponses, error) {
	client, err := NewClient(server, opts...)
	if err != nil {
		return nil, err
	}
	return &ClientWithResponses{client}, nil
}

// WithBaseURL overrides the baseURL.
func WithBaseURL(baseURL string) ClientOption {
	return func(c *Client) error {
		newBaseURL, err := url.Parse(baseURL)
		if err != nil {
			return err
		}
		c.Server = newBaseURL.String()
		return nil
	}
}

// ClientWithResponsesInterface is the interface specification for the client with responses above.
type ClientWithResponsesInterface interface {
	// GetJwksWithResponse request
	GetJwksWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetJwksResponse, error)

	// GetOpenidConfigurationWithResponse request
	GetOpenidConfigurationWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetOpenidConfigurationResponse, error)

	// InternalDeleteDeploymentsWithResponse request
	InternalDeleteDeploymentsWithResponse(ctx context.Context, orgId OrgIdPathParam, params *InternalDeleteDeploymentsParams, reqEditors ...RequestEditorFn) (*InternalDeleteDeploymentsResponse, error)

	// InternalForceFailDeploymentWithResponse request
	InternalForceFailDeploymentWithResponse(ctx context.Context, orgId OrgIdPathParam, deploymentId DeploymentIdPathParam, reqEditors ...RequestEditorFn) (*InternalForceFailDeploymentResponse, error)

	// InternalCheckModuleUsageWithResponse request
	InternalCheckModuleUsageWithResponse(ctx context.Context, orgId OrgIdPathParam, moduleId string, params *InternalCheckModuleUsageParams, reqEditors ...RequestEditorFn) (*InternalCheckModuleUsageResponse, error)

	// InternalPushMessageToRemoteRunnerWithBodyWithResponse request with any body
	InternalPushMessageToRemoteRunnerWithBodyWithResponse(ctx context.Context, orgId OrgIdPathParam, runnerId RunnerIdPathParam, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*InternalPushMessageToRemoteRunnerResponse, error)

	InternalPushMessageToRemoteRunnerWithResponse(ctx context.Context, orgId OrgIdPathParam, runnerId RunnerIdPathParam, body InternalPushMessageToRemoteRunnerJSONRequestBody, reqEditors ...RequestEditorFn) (*InternalPushMessageToRemoteRunnerResponse, error)

	// ListActiveResourceNodesWithResponse request
	ListActiveResourceNodesWithResponse(ctx context.Context, orgId OrgIdPathParam, params *ListActiveResourceNodesParams, reqEditors ...RequestEditorFn) (*ListActiveResourceNodesResponse, error)

	// ListDeploymentsWithResponse request
	ListDeploymentsWithResponse(ctx context.Context, orgId OrgIdPathParam, params *ListDeploymentsParams, reqEditors ...RequestEditorFn) (*ListDeploymentsResponse, error)

	// CreateDeploymentWithBodyWithResponse request with any body
	CreateDeploymentWithBodyWithResponse(ctx context.Context, orgId OrgIdPathParam, params *CreateDeploymentParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateDeploymentResponse, error)

	CreateDeploymentWithResponse(ctx context.Context, orgId OrgIdPathParam, params *CreateDeploymentParams, body CreateDeploymentJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateDeploymentResponse, error)

	// GetDeploymentWithResponse request
	GetDeploymentWithResponse(ctx context.Context, orgId OrgIdPathParam, deploymentId DeploymentIdPathParam, reqEditors ...RequestEditorFn) (*GetDeploymentResponse, error)

	// GetDeploymentLogsWithResponse request
	GetDeploymentLogsWithResponse(ctx context.Context, orgId OrgIdPathParam, deploymentId DeploymentIdPathParam, params *GetDeploymentLogsParams, reqEditors ...RequestEditorFn) (*GetDeploymentLogsResponse, error)

	// WaitForDeploymentCompleteWithResponse request
	WaitForDeploymentCompleteWithResponse(ctx context.Context, orgId OrgIdPathParam, deploymentId DeploymentIdPathParam, params *WaitForDeploymentCompleteParams, reqEditors ...RequestEditorFn) (*WaitForDeploymentCompleteResponse, error)

	// GetDeploymentBundleWithResponse request
	GetDeploymentBundleWithResponse(ctx context.Context, orgId OrgIdPathParam, deploymentId DeploymentIdPathParam, params *GetDeploymentBundleParams, reqEditors ...RequestEditorFn) (*GetDeploymentBundleResponse, error)

	// GetDeploymentEncryptedOutputsWithResponse request
	GetDeploymentEncryptedOutputsWithResponse(ctx context.Context, orgId OrgIdPathParam, deploymentId DeploymentIdPathParam, reqEditors ...RequestEditorFn) (*GetDeploymentEncryptedOutputsResponse, error)

	// UpdateDeploymentResultsWithBodyWithResponse request with any body
	UpdateDeploymentResultsWithBodyWithResponse(ctx context.Context, orgId OrgIdPathParam, deploymentId DeploymentIdPathParam, params *UpdateDeploymentResultsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateDeploymentResultsResponse, error)

	UpdateDeploymentResultsWithResponse(ctx context.Context, orgId OrgIdPathParam, deploymentId DeploymentIdPathParam, params *UpdateDeploymentResultsParams, body UpdateDeploymentResultsJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateDeploymentResultsResponse, error)

	// GetDeploymentTfWithResponse request
	GetDeploymentTfWithResponse(ctx context.Context, orgId OrgIdPathParam, deploymentId DeploymentIdPathParam, reqEditors ...RequestEditorFn) (*GetDeploymentTfResponse, error)

	// ListLastDeploymentsWithResponse request
	ListLastDeploymentsWithResponse(ctx context.Context, orgId OrgIdPathParam, params *ListLastDeploymentsParams, reqEditors ...RequestEditorFn) (*ListLastDeploymentsResponse, error)

	// ListMetadataKeysWithResponse request
	ListMetadataKeysWithResponse(ctx context.Context, orgId OrgIdPathParam, params *ListMetadataKeysParams, reqEditors ...RequestEditorFn) (*ListMetadataKeysResponse, error)

	// CreateMetadataKeyWithBodyWithResponse request with any body
	CreateMetadataKeyWithBodyWithResponse(ctx context.Context, orgId OrgIdPathParam, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateMetadataKeyResponse, error)

	CreateMetadataKeyWithResponse(ctx context.Context, orgId OrgIdPathParam, body CreateMetadataKeyJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateMetadataKeyResponse, error)

	// DeleteMetadataKeyWithResponse request
	DeleteMetadataKeyWithResponse(ctx context.Context, orgId OrgIdPathParam, metadataKeyName MetadataKeyNamePathParam, reqEditors ...RequestEditorFn) (*DeleteMetadataKeyResponse, error)

	// GetMetadataKeyWithResponse request
	GetMetadataKeyWithResponse(ctx context.Context, orgId OrgIdPathParam, metadataKeyName MetadataKeyNamePathParam, reqEditors ...RequestEditorFn) (*GetMetadataKeyResponse, error)

	// UpdateMetadataKeyWithBodyWithResponse request with any body
	UpdateMetadataKeyWithBodyWithResponse(ctx context.Context, orgId OrgIdPathParam, metadataKeyName MetadataKeyNamePathParam, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateMetadataKeyResponse, error)

	UpdateMetadataKeyWithResponse(ctx context.Context, orgId OrgIdPathParam, metadataKeyName MetadataKeyNamePathParam, body UpdateMetadataKeyJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateMetadataKeyResponse, error)

	// WaitForRemoteRunnerMessagesWithResponse request
	WaitForRemoteRunnerMessagesWithResponse(ctx context.Context, orgId OrgIdPathParam, runnerId RunnerIdPathParam, reqEditors ...RequestEditorFn) (*WaitForRemoteRunnerMessagesResponse, error)
}

type GetJwksResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Jwks
}

// Status returns HTTPResponse.Status
func (r GetJwksResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetJwksResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetOpenidConfigurationResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *OpenidConfiguration
}

// Status returns HTTPResponse.Status
func (r GetOpenidConfigurationResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetOpenidConfigurationResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type InternalDeleteDeploymentsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *N400BadRequest
	JSON404      *N404NotFound
	JSON409      *N409Conflict
}

// Status returns HTTPResponse.Status
func (r InternalDeleteDeploymentsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r InternalDeleteDeploymentsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type InternalForceFailDeploymentResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *DeploymentSummary
	JSON404      *N404NotFound
	JSON409      *N409Conflict
}

// Status returns HTTPResponse.Status
func (r InternalForceFailDeploymentResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r InternalForceFailDeploymentResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type InternalCheckModuleUsageResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *InternalModuleUsage
	JSON404      *N404NotFound
}

// Status returns HTTPResponse.Status
func (r InternalCheckModuleUsageResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r InternalCheckModuleUsageResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type InternalPushMessageToRemoteRunnerResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r InternalPushMessageToRemoteRunnerResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r InternalPushMessageToRemoteRunnerResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListActiveResourceNodesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ListActiveResourceNodesPage
	JSON400      *N400BadRequest
	JSON404      *N404NotFound
}

// Status returns HTTPResponse.Status
func (r ListActiveResourceNodesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListActiveResourceNodesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListDeploymentsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *DeploymentPage
	JSON400      *N400BadRequest
	JSON404      *N404NotFound
}

// Status returns HTTPResponse.Status
func (r ListDeploymentsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListDeploymentsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateDeploymentResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *DeploymentDryRun
	JSON201      *Deployment
	JSON400      *N400BadRequest
	JSON409      *N409Conflict
}

// Status returns HTTPResponse.Status
func (r CreateDeploymentResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateDeploymentResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetDeploymentResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Deployment
	JSON404      *N404NotFound
}

// Status returns HTTPResponse.Status
func (r GetDeploymentResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetDeploymentResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetDeploymentLogsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *N400BadRequest
	JSON404      *N404NotFound
}

// Status returns HTTPResponse.Status
func (r GetDeploymentLogsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetDeploymentLogsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type WaitForDeploymentCompleteResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Deployment
	JSON404      *N404NotFound
	JSON408      *Error
}

// Status returns HTTPResponse.Status
func (r WaitForDeploymentCompleteResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r WaitForDeploymentCompleteResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetDeploymentBundleResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *N400BadRequest
	JSON404      *N404NotFound
}

// Status returns HTTPResponse.Status
func (r GetDeploymentBundleResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetDeploymentBundleResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetDeploymentEncryptedOutputsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *DeploymentEncryptedOutputs
	JSON404      *N404NotFound
}

// Status returns HTTPResponse.Status
func (r GetDeploymentEncryptedOutputsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetDeploymentEncryptedOutputsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateDeploymentResultsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *N400BadRequest
	JSON404      *N404NotFound
	JSON409      *N409Conflict
}

// Status returns HTTPResponse.Status
func (r UpdateDeploymentResultsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateDeploymentResultsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetDeploymentTfResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON404      *N404NotFound
}

// Status returns HTTPResponse.Status
func (r GetDeploymentTfResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetDeploymentTfResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListLastDeploymentsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *DeploymentPage
	JSON400      *N400BadRequest
	JSON404      *N404NotFound
}

// Status returns HTTPResponse.Status
func (r ListLastDeploymentsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListLastDeploymentsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListMetadataKeysResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *MetadataKeyPage
	JSON404      *N404NotFound
}

// Status returns HTTPResponse.Status
func (r ListMetadataKeysResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListMetadataKeysResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateMetadataKeyResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *MetadataKey
	JSON400      *N400BadRequest
	JSON404      *N404NotFound
}

// Status returns HTTPResponse.Status
func (r CreateMetadataKeyResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateMetadataKeyResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteMetadataKeyResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON404      *N404NotFound
}

// Status returns HTTPResponse.Status
func (r DeleteMetadataKeyResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteMetadataKeyResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetMetadataKeyResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *MetadataKey
	JSON404      *N404NotFound
}

// Status returns HTTPResponse.Status
func (r GetMetadataKeyResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetMetadataKeyResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateMetadataKeyResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *MetadataKey
	JSON400      *N400BadRequest
	JSON404      *N404NotFound
}

// Status returns HTTPResponse.Status
func (r UpdateMetadataKeyResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateMetadataKeyResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type WaitForRemoteRunnerMessagesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RemoteRunnerMessage
	JSON404      *N404NotFound
}

// Status returns HTTPResponse.Status
func (r WaitForRemoteRunnerMessagesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r WaitForRemoteRunnerMessagesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// GetJwksWithResponse request returning *GetJwksResponse
func (c *ClientWithResponses) GetJwksWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetJwksResponse, error) {
	rsp, err := c.GetJwks(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetJwksResponse(rsp)
}

// GetOpenidConfigurationWithResponse request returning *GetOpenidConfigurationResponse
func (c *ClientWithResponses) GetOpenidConfigurationWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetOpenidConfigurationResponse, error) {
	rsp, err := c.GetOpenidConfiguration(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetOpenidConfigurationResponse(rsp)
}

// InternalDeleteDeploymentsWithResponse request returning *InternalDeleteDeploymentsResponse
func (c *ClientWithResponses) InternalDeleteDeploymentsWithResponse(ctx context.Context, orgId OrgIdPathParam, params *InternalDeleteDeploymentsParams, reqEditors ...RequestEditorFn) (*InternalDeleteDeploymentsResponse, error) {
	rsp, err := c.InternalDeleteDeployments(ctx, orgId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseInternalDeleteDeploymentsResponse(rsp)
}

// InternalForceFailDeploymentWithResponse request returning *InternalForceFailDeploymentResponse
func (c *ClientWithResponses) InternalForceFailDeploymentWithResponse(ctx context.Context, orgId OrgIdPathParam, deploymentId DeploymentIdPathParam, reqEditors ...RequestEditorFn) (*InternalForceFailDeploymentResponse, error) {
	rsp, err := c.InternalForceFailDeployment(ctx, orgId, deploymentId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseInternalForceFailDeploymentResponse(rsp)
}

// InternalCheckModuleUsageWithResponse request returning *InternalCheckModuleUsageResponse
func (c *ClientWithResponses) InternalCheckModuleUsageWithResponse(ctx context.Context, orgId OrgIdPathParam, moduleId string, params *InternalCheckModuleUsageParams, reqEditors ...RequestEditorFn) (*InternalCheckModuleUsageResponse, error) {
	rsp, err := c.InternalCheckModuleUsage(ctx, orgId, moduleId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseInternalCheckModuleUsageResponse(rsp)
}

// InternalPushMessageToRemoteRunnerWithBodyWithResponse request with arbitrary body returning *InternalPushMessageToRemoteRunnerResponse
func (c *ClientWithResponses) InternalPushMessageToRemoteRunnerWithBodyWithResponse(ctx context.Context, orgId OrgIdPathParam, runnerId RunnerIdPathParam, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*InternalPushMessageToRemoteRunnerResponse, error) {
	rsp, err := c.InternalPushMessageToRemoteRunnerWithBody(ctx, orgId, runnerId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseInternalPushMessageToRemoteRunnerResponse(rsp)
}

func (c *ClientWithResponses) InternalPushMessageToRemoteRunnerWithResponse(ctx context.Context, orgId OrgIdPathParam, runnerId RunnerIdPathParam, body InternalPushMessageToRemoteRunnerJSONRequestBody, reqEditors ...RequestEditorFn) (*InternalPushMessageToRemoteRunnerResponse, error) {
	rsp, err := c.InternalPushMessageToRemoteRunner(ctx, orgId, runnerId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseInternalPushMessageToRemoteRunnerResponse(rsp)
}

// ListActiveResourceNodesWithResponse request returning *ListActiveResourceNodesResponse
func (c *ClientWithResponses) ListActiveResourceNodesWithResponse(ctx context.Context, orgId OrgIdPathParam, params *ListActiveResourceNodesParams, reqEditors ...RequestEditorFn) (*ListActiveResourceNodesResponse, error) {
	rsp, err := c.ListActiveResourceNodes(ctx, orgId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListActiveResourceNodesResponse(rsp)
}

// ListDeploymentsWithResponse request returning *ListDeploymentsResponse
func (c *ClientWithResponses) ListDeploymentsWithResponse(ctx context.Context, orgId OrgIdPathParam, params *ListDeploymentsParams, reqEditors ...RequestEditorFn) (*ListDeploymentsResponse, error) {
	rsp, err := c.ListDeployments(ctx, orgId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListDeploymentsResponse(rsp)
}

// CreateDeploymentWithBodyWithResponse request with arbitrary body returning *CreateDeploymentResponse
func (c *ClientWithResponses) CreateDeploymentWithBodyWithResponse(ctx context.Context, orgId OrgIdPathParam, params *CreateDeploymentParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateDeploymentResponse, error) {
	rsp, err := c.CreateDeploymentWithBody(ctx, orgId, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateDeploymentResponse(rsp)
}

func (c *ClientWithResponses) CreateDeploymentWithResponse(ctx context.Context, orgId OrgIdPathParam, params *CreateDeploymentParams, body CreateDeploymentJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateDeploymentResponse, error) {
	rsp, err := c.CreateDeployment(ctx, orgId, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateDeploymentResponse(rsp)
}

// GetDeploymentWithResponse request returning *GetDeploymentResponse
func (c *ClientWithResponses) GetDeploymentWithResponse(ctx context.Context, orgId OrgIdPathParam, deploymentId DeploymentIdPathParam, reqEditors ...RequestEditorFn) (*GetDeploymentResponse, error) {
	rsp, err := c.GetDeployment(ctx, orgId, deploymentId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetDeploymentResponse(rsp)
}

// GetDeploymentLogsWithResponse request returning *GetDeploymentLogsResponse
func (c *ClientWithResponses) GetDeploymentLogsWithResponse(ctx context.Context, orgId OrgIdPathParam, deploymentId DeploymentIdPathParam, params *GetDeploymentLogsParams, reqEditors ...RequestEditorFn) (*GetDeploymentLogsResponse, error) {
	rsp, err := c.GetDeploymentLogs(ctx, orgId, deploymentId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetDeploymentLogsResponse(rsp)
}

// WaitForDeploymentCompleteWithResponse request returning *WaitForDeploymentCompleteResponse
func (c *ClientWithResponses) WaitForDeploymentCompleteWithResponse(ctx context.Context, orgId OrgIdPathParam, deploymentId DeploymentIdPathParam, params *WaitForDeploymentCompleteParams, reqEditors ...RequestEditorFn) (*WaitForDeploymentCompleteResponse, error) {
	rsp, err := c.WaitForDeploymentComplete(ctx, orgId, deploymentId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseWaitForDeploymentCompleteResponse(rsp)
}

// GetDeploymentBundleWithResponse request returning *GetDeploymentBundleResponse
func (c *ClientWithResponses) GetDeploymentBundleWithResponse(ctx context.Context, orgId OrgIdPathParam, deploymentId DeploymentIdPathParam, params *GetDeploymentBundleParams, reqEditors ...RequestEditorFn) (*GetDeploymentBundleResponse, error) {
	rsp, err := c.GetDeploymentBundle(ctx, orgId, deploymentId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetDeploymentBundleResponse(rsp)
}

// GetDeploymentEncryptedOutputsWithResponse request returning *GetDeploymentEncryptedOutputsResponse
func (c *ClientWithResponses) GetDeploymentEncryptedOutputsWithResponse(ctx context.Context, orgId OrgIdPathParam, deploymentId DeploymentIdPathParam, reqEditors ...RequestEditorFn) (*GetDeploymentEncryptedOutputsResponse, error) {
	rsp, err := c.GetDeploymentEncryptedOutputs(ctx, orgId, deploymentId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetDeploymentEncryptedOutputsResponse(rsp)
}

// UpdateDeploymentResultsWithBodyWithResponse request with arbitrary body returning *UpdateDeploymentResultsResponse
func (c *ClientWithResponses) UpdateDeploymentResultsWithBodyWithResponse(ctx context.Context, orgId OrgIdPathParam, deploymentId DeploymentIdPathParam, params *UpdateDeploymentResultsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateDeploymentResultsResponse, error) {
	rsp, err := c.UpdateDeploymentResultsWithBody(ctx, orgId, deploymentId, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateDeploymentResultsResponse(rsp)
}

func (c *ClientWithResponses) UpdateDeploymentResultsWithResponse(ctx context.Context, orgId OrgIdPathParam, deploymentId DeploymentIdPathParam, params *UpdateDeploymentResultsParams, body UpdateDeploymentResultsJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateDeploymentResultsResponse, error) {
	rsp, err := c.UpdateDeploymentResults(ctx, orgId, deploymentId, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateDeploymentResultsResponse(rsp)
}

// GetDeploymentTfWithResponse request returning *GetDeploymentTfResponse
func (c *ClientWithResponses) GetDeploymentTfWithResponse(ctx context.Context, orgId OrgIdPathParam, deploymentId DeploymentIdPathParam, reqEditors ...RequestEditorFn) (*GetDeploymentTfResponse, error) {
	rsp, err := c.GetDeploymentTf(ctx, orgId, deploymentId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetDeploymentTfResponse(rsp)
}

// ListLastDeploymentsWithResponse request returning *ListLastDeploymentsResponse
func (c *ClientWithResponses) ListLastDeploymentsWithResponse(ctx context.Context, orgId OrgIdPathParam, params *ListLastDeploymentsParams, reqEditors ...RequestEditorFn) (*ListLastDeploymentsResponse, error) {
	rsp, err := c.ListLastDeployments(ctx, orgId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListLastDeploymentsResponse(rsp)
}

// ListMetadataKeysWithResponse request returning *ListMetadataKeysResponse
func (c *ClientWithResponses) ListMetadataKeysWithResponse(ctx context.Context, orgId OrgIdPathParam, params *ListMetadataKeysParams, reqEditors ...RequestEditorFn) (*ListMetadataKeysResponse, error) {
	rsp, err := c.ListMetadataKeys(ctx, orgId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListMetadataKeysResponse(rsp)
}

// CreateMetadataKeyWithBodyWithResponse request with arbitrary body returning *CreateMetadataKeyResponse
func (c *ClientWithResponses) CreateMetadataKeyWithBodyWithResponse(ctx context.Context, orgId OrgIdPathParam, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateMetadataKeyResponse, error) {
	rsp, err := c.CreateMetadataKeyWithBody(ctx, orgId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateMetadataKeyResponse(rsp)
}

func (c *ClientWithResponses) CreateMetadataKeyWithResponse(ctx context.Context, orgId OrgIdPathParam, body CreateMetadataKeyJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateMetadataKeyResponse, error) {
	rsp, err := c.CreateMetadataKey(ctx, orgId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateMetadataKeyResponse(rsp)
}

// DeleteMetadataKeyWithResponse request returning *DeleteMetadataKeyResponse
func (c *ClientWithResponses) DeleteMetadataKeyWithResponse(ctx context.Context, orgId OrgIdPathParam, metadataKeyName MetadataKeyNamePathParam, reqEditors ...RequestEditorFn) (*DeleteMetadataKeyResponse, error) {
	rsp, err := c.DeleteMetadataKey(ctx, orgId, metadataKeyName, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteMetadataKeyResponse(rsp)
}

// GetMetadataKeyWithResponse request returning *GetMetadataKeyResponse
func (c *ClientWithResponses) GetMetadataKeyWithResponse(ctx context.Context, orgId OrgIdPathParam, metadataKeyName MetadataKeyNamePathParam, reqEditors ...RequestEditorFn) (*GetMetadataKeyResponse, error) {
	rsp, err := c.GetMetadataKey(ctx, orgId, metadataKeyName, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetMetadataKeyResponse(rsp)
}

// UpdateMetadataKeyWithBodyWithResponse request with arbitrary body returning *UpdateMetadataKeyResponse
func (c *ClientWithResponses) UpdateMetadataKeyWithBodyWithResponse(ctx context.Context, orgId OrgIdPathParam, metadataKeyName MetadataKeyNamePathParam, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateMetadataKeyResponse, error) {
	rsp, err := c.UpdateMetadataKeyWithBody(ctx, orgId, metadataKeyName, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateMetadataKeyResponse(rsp)
}

func (c *ClientWithResponses) UpdateMetadataKeyWithResponse(ctx context.Context, orgId OrgIdPathParam, metadataKeyName MetadataKeyNamePathParam, body UpdateMetadataKeyJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateMetadataKeyResponse, error) {
	rsp, err := c.UpdateMetadataKey(ctx, orgId, metadataKeyName, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateMetadataKeyResponse(rsp)
}

// WaitForRemoteRunnerMessagesWithResponse request returning *WaitForRemoteRunnerMessagesResponse
func (c *ClientWithResponses) WaitForRemoteRunnerMessagesWithResponse(ctx context.Context, orgId OrgIdPathParam, runnerId RunnerIdPathParam, reqEditors ...RequestEditorFn) (*WaitForRemoteRunnerMessagesResponse, error) {
	rsp, err := c.WaitForRemoteRunnerMessages(ctx, orgId, runnerId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseWaitForRemoteRunnerMessagesResponse(rsp)
}

// ParseGetJwksResponse parses an HTTP response from a GetJwksWithResponse call
func ParseGetJwksResponse(rsp *http.Response) (*GetJwksResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetJwksResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Jwks
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetOpenidConfigurationResponse parses an HTTP response from a GetOpenidConfigurationWithResponse call
func ParseGetOpenidConfigurationResponse(rsp *http.Response) (*GetOpenidConfigurationResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetOpenidConfigurationResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest OpenidConfiguration
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseInternalDeleteDeploymentsResponse parses an HTTP response from a InternalDeleteDeploymentsWithResponse call
func ParseInternalDeleteDeploymentsResponse(rsp *http.Response) (*InternalDeleteDeploymentsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &InternalDeleteDeploymentsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest N404NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest N409Conflict
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	}

	return response, nil
}

// ParseInternalForceFailDeploymentResponse parses an HTTP response from a InternalForceFailDeploymentWithResponse call
func ParseInternalForceFailDeploymentResponse(rsp *http.Response) (*InternalForceFailDeploymentResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &InternalForceFailDeploymentResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest DeploymentSummary
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest N404NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest N409Conflict
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	}

	return response, nil
}

// ParseInternalCheckModuleUsageResponse parses an HTTP response from a InternalCheckModuleUsageWithResponse call
func ParseInternalCheckModuleUsageResponse(rsp *http.Response) (*InternalCheckModuleUsageResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &InternalCheckModuleUsageResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest InternalModuleUsage
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest N404NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseInternalPushMessageToRemoteRunnerResponse parses an HTTP response from a InternalPushMessageToRemoteRunnerWithResponse call
func ParseInternalPushMessageToRemoteRunnerResponse(rsp *http.Response) (*InternalPushMessageToRemoteRunnerResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &InternalPushMessageToRemoteRunnerResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseListActiveResourceNodesResponse parses an HTTP response from a ListActiveResourceNodesWithResponse call
func ParseListActiveResourceNodesResponse(rsp *http.Response) (*ListActiveResourceNodesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListActiveResourceNodesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ListActiveResourceNodesPage
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest N404NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseListDeploymentsResponse parses an HTTP response from a ListDeploymentsWithResponse call
func ParseListDeploymentsResponse(rsp *http.Response) (*ListDeploymentsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListDeploymentsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest DeploymentPage
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest N404NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseCreateDeploymentResponse parses an HTTP response from a CreateDeploymentWithResponse call
func ParseCreateDeploymentResponse(rsp *http.Response) (*CreateDeploymentResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateDeploymentResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest DeploymentDryRun
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest Deployment
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest N409Conflict
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	}

	return response, nil
}

// ParseGetDeploymentResponse parses an HTTP response from a GetDeploymentWithResponse call
func ParseGetDeploymentResponse(rsp *http.Response) (*GetDeploymentResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetDeploymentResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Deployment
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest N404NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseGetDeploymentLogsResponse parses an HTTP response from a GetDeploymentLogsWithResponse call
func ParseGetDeploymentLogsResponse(rsp *http.Response) (*GetDeploymentLogsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetDeploymentLogsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest N404NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseWaitForDeploymentCompleteResponse parses an HTTP response from a WaitForDeploymentCompleteWithResponse call
func ParseWaitForDeploymentCompleteResponse(rsp *http.Response) (*WaitForDeploymentCompleteResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &WaitForDeploymentCompleteResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Deployment
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest N404NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 408:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON408 = &dest

	}

	return response, nil
}

// ParseGetDeploymentBundleResponse parses an HTTP response from a GetDeploymentBundleWithResponse call
func ParseGetDeploymentBundleResponse(rsp *http.Response) (*GetDeploymentBundleResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetDeploymentBundleResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest N404NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseGetDeploymentEncryptedOutputsResponse parses an HTTP response from a GetDeploymentEncryptedOutputsWithResponse call
func ParseGetDeploymentEncryptedOutputsResponse(rsp *http.Response) (*GetDeploymentEncryptedOutputsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetDeploymentEncryptedOutputsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest DeploymentEncryptedOutputs
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest N404NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseUpdateDeploymentResultsResponse parses an HTTP response from a UpdateDeploymentResultsWithResponse call
func ParseUpdateDeploymentResultsResponse(rsp *http.Response) (*UpdateDeploymentResultsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateDeploymentResultsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest N404NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest N409Conflict
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	}

	return response, nil
}

// ParseGetDeploymentTfResponse parses an HTTP response from a GetDeploymentTfWithResponse call
func ParseGetDeploymentTfResponse(rsp *http.Response) (*GetDeploymentTfResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetDeploymentTfResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest N404NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseListLastDeploymentsResponse parses an HTTP response from a ListLastDeploymentsWithResponse call
func ParseListLastDeploymentsResponse(rsp *http.Response) (*ListLastDeploymentsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListLastDeploymentsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest DeploymentPage
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest N404NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseListMetadataKeysResponse parses an HTTP response from a ListMetadataKeysWithResponse call
func ParseListMetadataKeysResponse(rsp *http.Response) (*ListMetadataKeysResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListMetadataKeysResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest MetadataKeyPage
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest N404NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseCreateMetadataKeyResponse parses an HTTP response from a CreateMetadataKeyWithResponse call
func ParseCreateMetadataKeyResponse(rsp *http.Response) (*CreateMetadataKeyResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateMetadataKeyResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest MetadataKey
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest N404NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseDeleteMetadataKeyResponse parses an HTTP response from a DeleteMetadataKeyWithResponse call
func ParseDeleteMetadataKeyResponse(rsp *http.Response) (*DeleteMetadataKeyResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteMetadataKeyResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest N404NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseGetMetadataKeyResponse parses an HTTP response from a GetMetadataKeyWithResponse call
func ParseGetMetadataKeyResponse(rsp *http.Response) (*GetMetadataKeyResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetMetadataKeyResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest MetadataKey
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest N404NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseUpdateMetadataKeyResponse parses an HTTP response from a UpdateMetadataKeyWithResponse call
func ParseUpdateMetadataKeyResponse(rsp *http.Response) (*UpdateMetadataKeyResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateMetadataKeyResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest MetadataKey
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest N404NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseWaitForRemoteRunnerMessagesResponse parses an HTTP response from a WaitForRemoteRunnerMessagesWithResponse call
func ParseWaitForRemoteRunnerMessagesResponse(rsp *http.Response) (*WaitForRemoteRunnerMessagesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &WaitForRemoteRunnerMessagesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RemoteRunnerMessage
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest N404NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}
